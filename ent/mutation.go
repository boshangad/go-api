// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/boshangad/v1/ent/app"
	"github.com/boshangad/v1/ent/appoption"
	"github.com/boshangad/v1/ent/appuser"
	"github.com/boshangad/v1/ent/appuserloginlog"
	"github.com/boshangad/v1/ent/appusertoken"
	"github.com/boshangad/v1/ent/emaillog"
	"github.com/boshangad/v1/ent/predicate"
	"github.com/boshangad/v1/ent/smslog"
	"github.com/boshangad/v1/ent/user"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApp             = "App"
	TypeAppOption       = "AppOption"
	TypeAppUser         = "AppUser"
	TypeAppUserLoginLog = "AppUserLoginLog"
	TypeAppUserToken    = "AppUserToken"
	TypeAuthAssgiment   = "AuthAssgiment"
	TypeAuthItem        = "AuthItem"
	TypeAuthItemChild   = "AuthItemChild"
	TypeAuthRole        = "AuthRole"
	TypeAuthRule        = "AuthRule"
	TypeEmailLog        = "EmailLog"
	TypeSmsLog          = "SmsLog"
	TypeUser            = "User"
)

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uint64
	delete_time             *int64
	adddelete_time          *int64
	create_time             *int64
	addcreate_time          *int64
	create_by               *uint64
	addcreate_by            *uint64
	update_time             *int64
	addupdate_time          *int64
	update_by               *uint64
	addupdate_by            *uint64
	alias                   *string
	type_id                 *uint64
	addtype_id              *uint64
	title                   *string
	intro                   *string
	mp_origin_id            *string
	app_id                  *string
	app_secret              *string
	has_payment_auth        *bool
	register_user_number    *uint64
	addregister_user_number *uint64
	status                  *uint
	addstatus               *uint
	clearedFields           map[string]struct{}
	appOptions              map[uint64]struct{}
	removedappOptions       map[uint64]struct{}
	clearedappOptions       bool
	done                    bool
	oldValue                func(context.Context) (*App, error)
	predicates              []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id uint64) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDeleteTime sets the "delete_time" field.
func (m *AppMutation) SetDeleteTime(i int64) {
	m.delete_time = &i
	m.adddelete_time = nil
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *AppMutation) DeleteTime() (r int64, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDeleteTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// AddDeleteTime adds i to the "delete_time" field.
func (m *AppMutation) AddDeleteTime(i int64) {
	if m.adddelete_time != nil {
		*m.adddelete_time += i
	} else {
		m.adddelete_time = &i
	}
}

// AddedDeleteTime returns the value that was added to the "delete_time" field in this mutation.
func (m *AppMutation) AddedDeleteTime() (r int64, exists bool) {
	v := m.adddelete_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *AppMutation) ResetDeleteTime() {
	m.delete_time = nil
	m.adddelete_time = nil
}

// SetCreateTime sets the "create_time" field.
func (m *AppMutation) SetCreateTime(i int64) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AppMutation) CreateTime() (r int64, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreateTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *AppMutation) AddCreateTime(i int64) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *AppMutation) AddedCreateTime() (r int64, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AppMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
}

// SetCreateBy sets the "create_by" field.
func (m *AppMutation) SetCreateBy(u uint64) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *AppMutation) CreateBy() (r uint64, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreateBy(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *AppMutation) AddCreateBy(u uint64) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *AppMutation) AddedCreateBy() (r uint64, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *AppMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AppMutation) SetUpdateTime(i int64) {
	m.update_time = &i
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AppMutation) UpdateTime() (r int64, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdateTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds i to the "update_time" field.
func (m *AppMutation) AddUpdateTime(i int64) {
	if m.addupdate_time != nil {
		*m.addupdate_time += i
	} else {
		m.addupdate_time = &i
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *AppMutation) AddedUpdateTime() (r int64, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AppMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
}

// SetUpdateBy sets the "update_by" field.
func (m *AppMutation) SetUpdateBy(u uint64) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *AppMutation) UpdateBy() (r uint64, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdateBy(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *AppMutation) AddUpdateBy(u uint64) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *AppMutation) AddedUpdateBy() (r uint64, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *AppMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
}

// SetAlias sets the "alias" field.
func (m *AppMutation) SetAlias(s string) {
	m.alias = &s
}

// Alias returns the value of the "alias" field in the mutation.
func (m *AppMutation) Alias() (r string, exists bool) {
	v := m.alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "alias" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ResetAlias resets all changes to the "alias" field.
func (m *AppMutation) ResetAlias() {
	m.alias = nil
}

// SetTypeID sets the "type_id" field.
func (m *AppMutation) SetTypeID(u uint64) {
	m.type_id = &u
	m.addtype_id = nil
}

// TypeID returns the value of the "type_id" field in the mutation.
func (m *AppMutation) TypeID() (r uint64, exists bool) {
	v := m.type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeID returns the old "type_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldTypeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeID: %w", err)
	}
	return oldValue.TypeID, nil
}

// AddTypeID adds u to the "type_id" field.
func (m *AppMutation) AddTypeID(u uint64) {
	if m.addtype_id != nil {
		*m.addtype_id += u
	} else {
		m.addtype_id = &u
	}
}

// AddedTypeID returns the value that was added to the "type_id" field in this mutation.
func (m *AppMutation) AddedTypeID() (r uint64, exists bool) {
	v := m.addtype_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTypeID resets all changes to the "type_id" field.
func (m *AppMutation) ResetTypeID() {
	m.type_id = nil
	m.addtype_id = nil
}

// SetTitle sets the "title" field.
func (m *AppMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AppMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AppMutation) ResetTitle() {
	m.title = nil
}

// SetIntro sets the "intro" field.
func (m *AppMutation) SetIntro(s string) {
	m.intro = &s
}

// Intro returns the value of the "intro" field in the mutation.
func (m *AppMutation) Intro() (r string, exists bool) {
	v := m.intro
	if v == nil {
		return
	}
	return *v, true
}

// OldIntro returns the old "intro" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldIntro(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIntro is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIntro requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntro: %w", err)
	}
	return oldValue.Intro, nil
}

// ResetIntro resets all changes to the "intro" field.
func (m *AppMutation) ResetIntro() {
	m.intro = nil
}

// SetMpOriginID sets the "mp_origin_id" field.
func (m *AppMutation) SetMpOriginID(s string) {
	m.mp_origin_id = &s
}

// MpOriginID returns the value of the "mp_origin_id" field in the mutation.
func (m *AppMutation) MpOriginID() (r string, exists bool) {
	v := m.mp_origin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMpOriginID returns the old "mp_origin_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldMpOriginID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMpOriginID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMpOriginID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpOriginID: %w", err)
	}
	return oldValue.MpOriginID, nil
}

// ResetMpOriginID resets all changes to the "mp_origin_id" field.
func (m *AppMutation) ResetMpOriginID() {
	m.mp_origin_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppMutation) ResetAppID() {
	m.app_id = nil
}

// SetAppSecret sets the "app_secret" field.
func (m *AppMutation) SetAppSecret(s string) {
	m.app_secret = &s
}

// AppSecret returns the value of the "app_secret" field in the mutation.
func (m *AppMutation) AppSecret() (r string, exists bool) {
	v := m.app_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldAppSecret returns the old "app_secret" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAppSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAppSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAppSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppSecret: %w", err)
	}
	return oldValue.AppSecret, nil
}

// ResetAppSecret resets all changes to the "app_secret" field.
func (m *AppMutation) ResetAppSecret() {
	m.app_secret = nil
}

// SetHasPaymentAuth sets the "has_payment_auth" field.
func (m *AppMutation) SetHasPaymentAuth(b bool) {
	m.has_payment_auth = &b
}

// HasPaymentAuth returns the value of the "has_payment_auth" field in the mutation.
func (m *AppMutation) HasPaymentAuth() (r bool, exists bool) {
	v := m.has_payment_auth
	if v == nil {
		return
	}
	return *v, true
}

// OldHasPaymentAuth returns the old "has_payment_auth" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldHasPaymentAuth(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasPaymentAuth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasPaymentAuth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasPaymentAuth: %w", err)
	}
	return oldValue.HasPaymentAuth, nil
}

// ResetHasPaymentAuth resets all changes to the "has_payment_auth" field.
func (m *AppMutation) ResetHasPaymentAuth() {
	m.has_payment_auth = nil
}

// SetRegisterUserNumber sets the "register_user_number" field.
func (m *AppMutation) SetRegisterUserNumber(u uint64) {
	m.register_user_number = &u
	m.addregister_user_number = nil
}

// RegisterUserNumber returns the value of the "register_user_number" field in the mutation.
func (m *AppMutation) RegisterUserNumber() (r uint64, exists bool) {
	v := m.register_user_number
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterUserNumber returns the old "register_user_number" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldRegisterUserNumber(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRegisterUserNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRegisterUserNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterUserNumber: %w", err)
	}
	return oldValue.RegisterUserNumber, nil
}

// AddRegisterUserNumber adds u to the "register_user_number" field.
func (m *AppMutation) AddRegisterUserNumber(u uint64) {
	if m.addregister_user_number != nil {
		*m.addregister_user_number += u
	} else {
		m.addregister_user_number = &u
	}
}

// AddedRegisterUserNumber returns the value that was added to the "register_user_number" field in this mutation.
func (m *AppMutation) AddedRegisterUserNumber() (r uint64, exists bool) {
	v := m.addregister_user_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegisterUserNumber resets all changes to the "register_user_number" field.
func (m *AppMutation) ResetRegisterUserNumber() {
	m.register_user_number = nil
	m.addregister_user_number = nil
}

// SetStatus sets the "status" field.
func (m *AppMutation) SetStatus(u uint) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AppMutation) Status() (r uint, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldStatus(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *AppMutation) AddStatus(u uint) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AppMutation) AddedStatus() (r uint, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AppMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// AddAppOptionIDs adds the "appOptions" edge to the AppOption entity by ids.
func (m *AppMutation) AddAppOptionIDs(ids ...uint64) {
	if m.appOptions == nil {
		m.appOptions = make(map[uint64]struct{})
	}
	for i := range ids {
		m.appOptions[ids[i]] = struct{}{}
	}
}

// ClearAppOptions clears the "appOptions" edge to the AppOption entity.
func (m *AppMutation) ClearAppOptions() {
	m.clearedappOptions = true
}

// AppOptionsCleared reports if the "appOptions" edge to the AppOption entity was cleared.
func (m *AppMutation) AppOptionsCleared() bool {
	return m.clearedappOptions
}

// RemoveAppOptionIDs removes the "appOptions" edge to the AppOption entity by IDs.
func (m *AppMutation) RemoveAppOptionIDs(ids ...uint64) {
	if m.removedappOptions == nil {
		m.removedappOptions = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.appOptions, ids[i])
		m.removedappOptions[ids[i]] = struct{}{}
	}
}

// RemovedAppOptions returns the removed IDs of the "appOptions" edge to the AppOption entity.
func (m *AppMutation) RemovedAppOptionsIDs() (ids []uint64) {
	for id := range m.removedappOptions {
		ids = append(ids, id)
	}
	return
}

// AppOptionsIDs returns the "appOptions" edge IDs in the mutation.
func (m *AppMutation) AppOptionsIDs() (ids []uint64) {
	for id := range m.appOptions {
		ids = append(ids, id)
	}
	return
}

// ResetAppOptions resets all changes to the "appOptions" edge.
func (m *AppMutation) ResetAppOptions() {
	m.appOptions = nil
	m.clearedappOptions = false
	m.removedappOptions = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.delete_time != nil {
		fields = append(fields, app.FieldDeleteTime)
	}
	if m.create_time != nil {
		fields = append(fields, app.FieldCreateTime)
	}
	if m.create_by != nil {
		fields = append(fields, app.FieldCreateBy)
	}
	if m.update_time != nil {
		fields = append(fields, app.FieldUpdateTime)
	}
	if m.update_by != nil {
		fields = append(fields, app.FieldUpdateBy)
	}
	if m.alias != nil {
		fields = append(fields, app.FieldAlias)
	}
	if m.type_id != nil {
		fields = append(fields, app.FieldTypeID)
	}
	if m.title != nil {
		fields = append(fields, app.FieldTitle)
	}
	if m.intro != nil {
		fields = append(fields, app.FieldIntro)
	}
	if m.mp_origin_id != nil {
		fields = append(fields, app.FieldMpOriginID)
	}
	if m.app_id != nil {
		fields = append(fields, app.FieldAppID)
	}
	if m.app_secret != nil {
		fields = append(fields, app.FieldAppSecret)
	}
	if m.has_payment_auth != nil {
		fields = append(fields, app.FieldHasPaymentAuth)
	}
	if m.register_user_number != nil {
		fields = append(fields, app.FieldRegisterUserNumber)
	}
	if m.status != nil {
		fields = append(fields, app.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldDeleteTime:
		return m.DeleteTime()
	case app.FieldCreateTime:
		return m.CreateTime()
	case app.FieldCreateBy:
		return m.CreateBy()
	case app.FieldUpdateTime:
		return m.UpdateTime()
	case app.FieldUpdateBy:
		return m.UpdateBy()
	case app.FieldAlias:
		return m.Alias()
	case app.FieldTypeID:
		return m.TypeID()
	case app.FieldTitle:
		return m.Title()
	case app.FieldIntro:
		return m.Intro()
	case app.FieldMpOriginID:
		return m.MpOriginID()
	case app.FieldAppID:
		return m.AppID()
	case app.FieldAppSecret:
		return m.AppSecret()
	case app.FieldHasPaymentAuth:
		return m.HasPaymentAuth()
	case app.FieldRegisterUserNumber:
		return m.RegisterUserNumber()
	case app.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case app.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case app.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case app.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case app.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case app.FieldAlias:
		return m.OldAlias(ctx)
	case app.FieldTypeID:
		return m.OldTypeID(ctx)
	case app.FieldTitle:
		return m.OldTitle(ctx)
	case app.FieldIntro:
		return m.OldIntro(ctx)
	case app.FieldMpOriginID:
		return m.OldMpOriginID(ctx)
	case app.FieldAppID:
		return m.OldAppID(ctx)
	case app.FieldAppSecret:
		return m.OldAppSecret(ctx)
	case app.FieldHasPaymentAuth:
		return m.OldHasPaymentAuth(ctx)
	case app.FieldRegisterUserNumber:
		return m.OldRegisterUserNumber(ctx)
	case app.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case app.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case app.FieldCreateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case app.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case app.FieldUpdateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case app.FieldAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	case app.FieldTypeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeID(v)
		return nil
	case app.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case app.FieldIntro:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntro(v)
		return nil
	case app.FieldMpOriginID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpOriginID(v)
		return nil
	case app.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case app.FieldAppSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppSecret(v)
		return nil
	case app.FieldHasPaymentAuth:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasPaymentAuth(v)
		return nil
	case app.FieldRegisterUserNumber:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterUserNumber(v)
		return nil
	case app.FieldStatus:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	var fields []string
	if m.adddelete_time != nil {
		fields = append(fields, app.FieldDeleteTime)
	}
	if m.addcreate_time != nil {
		fields = append(fields, app.FieldCreateTime)
	}
	if m.addcreate_by != nil {
		fields = append(fields, app.FieldCreateBy)
	}
	if m.addupdate_time != nil {
		fields = append(fields, app.FieldUpdateTime)
	}
	if m.addupdate_by != nil {
		fields = append(fields, app.FieldUpdateBy)
	}
	if m.addtype_id != nil {
		fields = append(fields, app.FieldTypeID)
	}
	if m.addregister_user_number != nil {
		fields = append(fields, app.FieldRegisterUserNumber)
	}
	if m.addstatus != nil {
		fields = append(fields, app.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case app.FieldDeleteTime:
		return m.AddedDeleteTime()
	case app.FieldCreateTime:
		return m.AddedCreateTime()
	case app.FieldCreateBy:
		return m.AddedCreateBy()
	case app.FieldUpdateTime:
		return m.AddedUpdateTime()
	case app.FieldUpdateBy:
		return m.AddedUpdateBy()
	case app.FieldTypeID:
		return m.AddedTypeID()
	case app.FieldRegisterUserNumber:
		return m.AddedRegisterUserNumber()
	case app.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case app.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteTime(v)
		return nil
	case app.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case app.FieldCreateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case app.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	case app.FieldUpdateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case app.FieldTypeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTypeID(v)
		return nil
	case app.FieldRegisterUserNumber:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegisterUserNumber(v)
		return nil
	case app.FieldStatus:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case app.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case app.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case app.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case app.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case app.FieldAlias:
		m.ResetAlias()
		return nil
	case app.FieldTypeID:
		m.ResetTypeID()
		return nil
	case app.FieldTitle:
		m.ResetTitle()
		return nil
	case app.FieldIntro:
		m.ResetIntro()
		return nil
	case app.FieldMpOriginID:
		m.ResetMpOriginID()
		return nil
	case app.FieldAppID:
		m.ResetAppID()
		return nil
	case app.FieldAppSecret:
		m.ResetAppSecret()
		return nil
	case app.FieldHasPaymentAuth:
		m.ResetHasPaymentAuth()
		return nil
	case app.FieldRegisterUserNumber:
		m.ResetRegisterUserNumber()
		return nil
	case app.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.appOptions != nil {
		edges = append(edges, app.EdgeAppOptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeAppOptions:
		ids := make([]ent.Value, 0, len(m.appOptions))
		for id := range m.appOptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedappOptions != nil {
		edges = append(edges, app.EdgeAppOptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeAppOptions:
		ids := make([]ent.Value, 0, len(m.removedappOptions))
		for id := range m.removedappOptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedappOptions {
		edges = append(edges, app.EdgeAppOptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgeAppOptions:
		return m.clearedappOptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeAppOptions:
		m.ResetAppOptions()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// AppOptionMutation represents an operation that mutates the AppOption nodes in the graph.
type AppOptionMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	create_time    *int64
	addcreate_time *int64
	create_by      *uint64
	addcreate_by   *uint64
	update_time    *int64
	addupdate_time *int64
	update_by      *uint64
	addupdate_by   *uint64
	title          *string
	description    *string
	name           *string
	value          *string
	expire_time    *uint64
	addexpire_time *uint64
	edit_type      *uint
	addedit_type   *uint
	clearedFields  map[string]struct{}
	app            *uint64
	clearedapp     bool
	done           bool
	oldValue       func(context.Context) (*AppOption, error)
	predicates     []predicate.AppOption
}

var _ ent.Mutation = (*AppOptionMutation)(nil)

// appoptionOption allows management of the mutation configuration using functional options.
type appoptionOption func(*AppOptionMutation)

// newAppOptionMutation creates new mutation for the AppOption entity.
func newAppOptionMutation(c config, op Op, opts ...appoptionOption) *AppOptionMutation {
	m := &AppOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeAppOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppOptionID sets the ID field of the mutation.
func withAppOptionID(id uint64) appoptionOption {
	return func(m *AppOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *AppOption
		)
		m.oldValue = func(ctx context.Context) (*AppOption, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppOption sets the old AppOption of the mutation.
func withAppOption(node *AppOption) appoptionOption {
	return func(m *AppOptionMutation) {
		m.oldValue = func(context.Context) (*AppOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppOption entities.
func (m *AppOptionMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppOptionMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *AppOptionMutation) SetCreateTime(i int64) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AppOptionMutation) CreateTime() (r int64, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AppOption entity.
// If the AppOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOptionMutation) OldCreateTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *AppOptionMutation) AddCreateTime(i int64) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *AppOptionMutation) AddedCreateTime() (r int64, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AppOptionMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
}

// SetCreateBy sets the "create_by" field.
func (m *AppOptionMutation) SetCreateBy(u uint64) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *AppOptionMutation) CreateBy() (r uint64, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the AppOption entity.
// If the AppOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOptionMutation) OldCreateBy(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *AppOptionMutation) AddCreateBy(u uint64) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *AppOptionMutation) AddedCreateBy() (r uint64, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *AppOptionMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AppOptionMutation) SetUpdateTime(i int64) {
	m.update_time = &i
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AppOptionMutation) UpdateTime() (r int64, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AppOption entity.
// If the AppOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOptionMutation) OldUpdateTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds i to the "update_time" field.
func (m *AppOptionMutation) AddUpdateTime(i int64) {
	if m.addupdate_time != nil {
		*m.addupdate_time += i
	} else {
		m.addupdate_time = &i
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *AppOptionMutation) AddedUpdateTime() (r int64, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AppOptionMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
}

// SetUpdateBy sets the "update_by" field.
func (m *AppOptionMutation) SetUpdateBy(u uint64) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *AppOptionMutation) UpdateBy() (r uint64, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the AppOption entity.
// If the AppOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOptionMutation) OldUpdateBy(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *AppOptionMutation) AddUpdateBy(u uint64) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *AppOptionMutation) AddedUpdateBy() (r uint64, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *AppOptionMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
}

// SetAppID sets the "app_id" field.
func (m *AppOptionMutation) SetAppID(u uint64) {
	m.app = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppOptionMutation) AppID() (r uint64, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppOption entity.
// If the AppOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOptionMutation) OldAppID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppOptionMutation) ResetAppID() {
	m.app = nil
}

// SetTitle sets the "title" field.
func (m *AppOptionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AppOptionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the AppOption entity.
// If the AppOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOptionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AppOptionMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *AppOptionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppOptionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AppOption entity.
// If the AppOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOptionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AppOptionMutation) ResetDescription() {
	m.description = nil
}

// SetName sets the "name" field.
func (m *AppOptionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppOptionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppOption entity.
// If the AppOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOptionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppOptionMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *AppOptionMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *AppOptionMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the AppOption entity.
// If the AppOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOptionMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *AppOptionMutation) ResetValue() {
	m.value = nil
}

// SetExpireTime sets the "expire_time" field.
func (m *AppOptionMutation) SetExpireTime(u uint64) {
	m.expire_time = &u
	m.addexpire_time = nil
}

// ExpireTime returns the value of the "expire_time" field in the mutation.
func (m *AppOptionMutation) ExpireTime() (r uint64, exists bool) {
	v := m.expire_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireTime returns the old "expire_time" field's value of the AppOption entity.
// If the AppOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOptionMutation) OldExpireTime(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpireTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpireTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireTime: %w", err)
	}
	return oldValue.ExpireTime, nil
}

// AddExpireTime adds u to the "expire_time" field.
func (m *AppOptionMutation) AddExpireTime(u uint64) {
	if m.addexpire_time != nil {
		*m.addexpire_time += u
	} else {
		m.addexpire_time = &u
	}
}

// AddedExpireTime returns the value that was added to the "expire_time" field in this mutation.
func (m *AppOptionMutation) AddedExpireTime() (r uint64, exists bool) {
	v := m.addexpire_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpireTime resets all changes to the "expire_time" field.
func (m *AppOptionMutation) ResetExpireTime() {
	m.expire_time = nil
	m.addexpire_time = nil
}

// SetEditType sets the "edit_type" field.
func (m *AppOptionMutation) SetEditType(u uint) {
	m.edit_type = &u
	m.addedit_type = nil
}

// EditType returns the value of the "edit_type" field in the mutation.
func (m *AppOptionMutation) EditType() (r uint, exists bool) {
	v := m.edit_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEditType returns the old "edit_type" field's value of the AppOption entity.
// If the AppOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppOptionMutation) OldEditType(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEditType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEditType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditType: %w", err)
	}
	return oldValue.EditType, nil
}

// AddEditType adds u to the "edit_type" field.
func (m *AppOptionMutation) AddEditType(u uint) {
	if m.addedit_type != nil {
		*m.addedit_type += u
	} else {
		m.addedit_type = &u
	}
}

// AddedEditType returns the value that was added to the "edit_type" field in this mutation.
func (m *AppOptionMutation) AddedEditType() (r uint, exists bool) {
	v := m.addedit_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetEditType resets all changes to the "edit_type" field.
func (m *AppOptionMutation) ResetEditType() {
	m.edit_type = nil
	m.addedit_type = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppOptionMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppOptionMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppOptionMutation) AppIDs() (ids []uint64) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppOptionMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// Where appends a list predicates to the AppOptionMutation builder.
func (m *AppOptionMutation) Where(ps ...predicate.AppOption) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppOptionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppOption).
func (m *AppOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppOptionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, appoption.FieldCreateTime)
	}
	if m.create_by != nil {
		fields = append(fields, appoption.FieldCreateBy)
	}
	if m.update_time != nil {
		fields = append(fields, appoption.FieldUpdateTime)
	}
	if m.update_by != nil {
		fields = append(fields, appoption.FieldUpdateBy)
	}
	if m.app != nil {
		fields = append(fields, appoption.FieldAppID)
	}
	if m.title != nil {
		fields = append(fields, appoption.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, appoption.FieldDescription)
	}
	if m.name != nil {
		fields = append(fields, appoption.FieldName)
	}
	if m.value != nil {
		fields = append(fields, appoption.FieldValue)
	}
	if m.expire_time != nil {
		fields = append(fields, appoption.FieldExpireTime)
	}
	if m.edit_type != nil {
		fields = append(fields, appoption.FieldEditType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appoption.FieldCreateTime:
		return m.CreateTime()
	case appoption.FieldCreateBy:
		return m.CreateBy()
	case appoption.FieldUpdateTime:
		return m.UpdateTime()
	case appoption.FieldUpdateBy:
		return m.UpdateBy()
	case appoption.FieldAppID:
		return m.AppID()
	case appoption.FieldTitle:
		return m.Title()
	case appoption.FieldDescription:
		return m.Description()
	case appoption.FieldName:
		return m.Name()
	case appoption.FieldValue:
		return m.Value()
	case appoption.FieldExpireTime:
		return m.ExpireTime()
	case appoption.FieldEditType:
		return m.EditType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appoption.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case appoption.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case appoption.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case appoption.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case appoption.FieldAppID:
		return m.OldAppID(ctx)
	case appoption.FieldTitle:
		return m.OldTitle(ctx)
	case appoption.FieldDescription:
		return m.OldDescription(ctx)
	case appoption.FieldName:
		return m.OldName(ctx)
	case appoption.FieldValue:
		return m.OldValue(ctx)
	case appoption.FieldExpireTime:
		return m.OldExpireTime(ctx)
	case appoption.FieldEditType:
		return m.OldEditType(ctx)
	}
	return nil, fmt.Errorf("unknown AppOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appoption.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case appoption.FieldCreateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case appoption.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case appoption.FieldUpdateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case appoption.FieldAppID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appoption.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case appoption.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case appoption.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appoption.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case appoption.FieldExpireTime:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireTime(v)
		return nil
	case appoption.FieldEditType:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditType(v)
		return nil
	}
	return fmt.Errorf("unknown AppOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppOptionMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_time != nil {
		fields = append(fields, appoption.FieldCreateTime)
	}
	if m.addcreate_by != nil {
		fields = append(fields, appoption.FieldCreateBy)
	}
	if m.addupdate_time != nil {
		fields = append(fields, appoption.FieldUpdateTime)
	}
	if m.addupdate_by != nil {
		fields = append(fields, appoption.FieldUpdateBy)
	}
	if m.addexpire_time != nil {
		fields = append(fields, appoption.FieldExpireTime)
	}
	if m.addedit_type != nil {
		fields = append(fields, appoption.FieldEditType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppOptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appoption.FieldCreateTime:
		return m.AddedCreateTime()
	case appoption.FieldCreateBy:
		return m.AddedCreateBy()
	case appoption.FieldUpdateTime:
		return m.AddedUpdateTime()
	case appoption.FieldUpdateBy:
		return m.AddedUpdateBy()
	case appoption.FieldExpireTime:
		return m.AddedExpireTime()
	case appoption.FieldEditType:
		return m.AddedEditType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appoption.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case appoption.FieldCreateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case appoption.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	case appoption.FieldUpdateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case appoption.FieldExpireTime:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpireTime(v)
		return nil
	case appoption.FieldEditType:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEditType(v)
		return nil
	}
	return fmt.Errorf("unknown AppOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppOptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppOptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppOptionMutation) ResetField(name string) error {
	switch name {
	case appoption.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case appoption.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case appoption.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case appoption.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case appoption.FieldAppID:
		m.ResetAppID()
		return nil
	case appoption.FieldTitle:
		m.ResetTitle()
		return nil
	case appoption.FieldDescription:
		m.ResetDescription()
		return nil
	case appoption.FieldName:
		m.ResetName()
		return nil
	case appoption.FieldValue:
		m.ResetValue()
		return nil
	case appoption.FieldExpireTime:
		m.ResetExpireTime()
		return nil
	case appoption.FieldEditType:
		m.ResetEditType()
		return nil
	}
	return fmt.Errorf("unknown AppOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.app != nil {
		edges = append(edges, appoption.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppOptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appoption.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppOptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapp {
		edges = append(edges, appoption.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppOptionMutation) EdgeCleared(name string) bool {
	switch name {
	case appoption.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppOptionMutation) ClearEdge(name string) error {
	switch name {
	case appoption.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppOptionMutation) ResetEdge(name string) error {
	switch name {
	case appoption.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown AppOption edge %s", name)
}

// AppUserMutation represents an operation that mutates the AppUser nodes in the graph.
type AppUserMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uint64
	create_time               *int64
	addcreate_time            *int64
	update_time               *int64
	addupdate_time            *int64
	open_id                   *string
	unionid                   *string
	session_key               *string
	is_load_user_profile      *bool
	nickname                  *string
	avatar                    *string
	avatar_url                *string
	gender                    *uint
	addgender                 *uint
	county                    *string
	country_code              *string
	province                  *string
	city                      *string
	language                  *string
	phone_number              *string
	pure_phone_number         *string
	watermark                 *string
	load_user_profile_time    *uint64
	addload_user_profile_time *uint64
	last_login_time           *uint64
	addlast_login_time        *uint64
	clearedFields             map[string]struct{}
	app                       *uint64
	clearedapp                bool
	user                      *uint64
	cleareduser               bool
	done                      bool
	oldValue                  func(context.Context) (*AppUser, error)
	predicates                []predicate.AppUser
}

var _ ent.Mutation = (*AppUserMutation)(nil)

// appuserOption allows management of the mutation configuration using functional options.
type appuserOption func(*AppUserMutation)

// newAppUserMutation creates new mutation for the AppUser entity.
func newAppUserMutation(c config, op Op, opts ...appuserOption) *AppUserMutation {
	m := &AppUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserID sets the ID field of the mutation.
func withAppUserID(id uint64) appuserOption {
	return func(m *AppUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUser
		)
		m.oldValue = func(ctx context.Context) (*AppUser, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUser sets the old AppUser of the mutation.
func withAppUser(node *AppUser) appuserOption {
	return func(m *AppUserMutation) {
		m.oldValue = func(context.Context) (*AppUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUser entities.
func (m *AppUserMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *AppUserMutation) SetCreateTime(i int64) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AppUserMutation) CreateTime() (r int64, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldCreateTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *AppUserMutation) AddCreateTime(i int64) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *AppUserMutation) AddedCreateTime() (r int64, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AppUserMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AppUserMutation) SetUpdateTime(i int64) {
	m.update_time = &i
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AppUserMutation) UpdateTime() (r int64, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldUpdateTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds i to the "update_time" field.
func (m *AppUserMutation) AddUpdateTime(i int64) {
	if m.addupdate_time != nil {
		*m.addupdate_time += i
	} else {
		m.addupdate_time = &i
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *AppUserMutation) AddedUpdateTime() (r int64, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AppUserMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserMutation) SetAppID(u uint64) {
	m.app = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserMutation) AppID() (r uint64, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldAppID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserMutation) ResetAppID() {
	m.app = nil
}

// SetUserID sets the "user_id" field.
func (m *AppUserMutation) SetUserID(u uint64) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserMutation) UserID() (r uint64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserMutation) ResetUserID() {
	m.user = nil
}

// SetOpenID sets the "open_id" field.
func (m *AppUserMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *AppUserMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *AppUserMutation) ResetOpenID() {
	m.open_id = nil
}

// SetUnionid sets the "unionid" field.
func (m *AppUserMutation) SetUnionid(s string) {
	m.unionid = &s
}

// Unionid returns the value of the "unionid" field in the mutation.
func (m *AppUserMutation) Unionid() (r string, exists bool) {
	v := m.unionid
	if v == nil {
		return
	}
	return *v, true
}

// OldUnionid returns the old "unionid" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldUnionid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUnionid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUnionid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnionid: %w", err)
	}
	return oldValue.Unionid, nil
}

// ResetUnionid resets all changes to the "unionid" field.
func (m *AppUserMutation) ResetUnionid() {
	m.unionid = nil
}

// SetSessionKey sets the "session_key" field.
func (m *AppUserMutation) SetSessionKey(s string) {
	m.session_key = &s
}

// SessionKey returns the value of the "session_key" field in the mutation.
func (m *AppUserMutation) SessionKey() (r string, exists bool) {
	v := m.session_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionKey returns the old "session_key" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldSessionKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSessionKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSessionKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionKey: %w", err)
	}
	return oldValue.SessionKey, nil
}

// ResetSessionKey resets all changes to the "session_key" field.
func (m *AppUserMutation) ResetSessionKey() {
	m.session_key = nil
}

// SetIsLoadUserProfile sets the "is_load_user_profile" field.
func (m *AppUserMutation) SetIsLoadUserProfile(b bool) {
	m.is_load_user_profile = &b
}

// IsLoadUserProfile returns the value of the "is_load_user_profile" field in the mutation.
func (m *AppUserMutation) IsLoadUserProfile() (r bool, exists bool) {
	v := m.is_load_user_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLoadUserProfile returns the old "is_load_user_profile" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldIsLoadUserProfile(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsLoadUserProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsLoadUserProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLoadUserProfile: %w", err)
	}
	return oldValue.IsLoadUserProfile, nil
}

// ResetIsLoadUserProfile resets all changes to the "is_load_user_profile" field.
func (m *AppUserMutation) ResetIsLoadUserProfile() {
	m.is_load_user_profile = nil
}

// SetNickname sets the "nickname" field.
func (m *AppUserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AppUserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AppUserMutation) ResetNickname() {
	m.nickname = nil
}

// SetAvatar sets the "avatar" field.
func (m *AppUserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *AppUserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *AppUserMutation) ResetAvatar() {
	m.avatar = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *AppUserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *AppUserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *AppUserMutation) ResetAvatarURL() {
	m.avatar_url = nil
}

// SetGender sets the "gender" field.
func (m *AppUserMutation) SetGender(u uint) {
	m.gender = &u
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *AppUserMutation) Gender() (r uint, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldGender(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds u to the "gender" field.
func (m *AppUserMutation) AddGender(u uint) {
	if m.addgender != nil {
		*m.addgender += u
	} else {
		m.addgender = &u
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *AppUserMutation) AddedGender() (r uint, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ResetGender resets all changes to the "gender" field.
func (m *AppUserMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
}

// SetCounty sets the "county" field.
func (m *AppUserMutation) SetCounty(s string) {
	m.county = &s
}

// County returns the value of the "county" field in the mutation.
func (m *AppUserMutation) County() (r string, exists bool) {
	v := m.county
	if v == nil {
		return
	}
	return *v, true
}

// OldCounty returns the old "county" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldCounty(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCounty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCounty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCounty: %w", err)
	}
	return oldValue.County, nil
}

// ResetCounty resets all changes to the "county" field.
func (m *AppUserMutation) ResetCounty() {
	m.county = nil
}

// SetCountryCode sets the "country_code" field.
func (m *AppUserMutation) SetCountryCode(s string) {
	m.country_code = &s
}

// CountryCode returns the value of the "country_code" field in the mutation.
func (m *AppUserMutation) CountryCode() (r string, exists bool) {
	v := m.country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryCode returns the old "country_code" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryCode: %w", err)
	}
	return oldValue.CountryCode, nil
}

// ResetCountryCode resets all changes to the "country_code" field.
func (m *AppUserMutation) ResetCountryCode() {
	m.country_code = nil
}

// SetProvince sets the "province" field.
func (m *AppUserMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *AppUserMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ResetProvince resets all changes to the "province" field.
func (m *AppUserMutation) ResetProvince() {
	m.province = nil
}

// SetCity sets the "city" field.
func (m *AppUserMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AppUserMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *AppUserMutation) ResetCity() {
	m.city = nil
}

// SetLanguage sets the "language" field.
func (m *AppUserMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *AppUserMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *AppUserMutation) ResetLanguage() {
	m.language = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *AppUserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *AppUserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *AppUserMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetPurePhoneNumber sets the "pure_phone_number" field.
func (m *AppUserMutation) SetPurePhoneNumber(s string) {
	m.pure_phone_number = &s
}

// PurePhoneNumber returns the value of the "pure_phone_number" field in the mutation.
func (m *AppUserMutation) PurePhoneNumber() (r string, exists bool) {
	v := m.pure_phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPurePhoneNumber returns the old "pure_phone_number" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldPurePhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPurePhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPurePhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurePhoneNumber: %w", err)
	}
	return oldValue.PurePhoneNumber, nil
}

// ResetPurePhoneNumber resets all changes to the "pure_phone_number" field.
func (m *AppUserMutation) ResetPurePhoneNumber() {
	m.pure_phone_number = nil
}

// SetWatermark sets the "watermark" field.
func (m *AppUserMutation) SetWatermark(s string) {
	m.watermark = &s
}

// Watermark returns the value of the "watermark" field in the mutation.
func (m *AppUserMutation) Watermark() (r string, exists bool) {
	v := m.watermark
	if v == nil {
		return
	}
	return *v, true
}

// OldWatermark returns the old "watermark" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldWatermark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWatermark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWatermark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWatermark: %w", err)
	}
	return oldValue.Watermark, nil
}

// ResetWatermark resets all changes to the "watermark" field.
func (m *AppUserMutation) ResetWatermark() {
	m.watermark = nil
}

// SetLoadUserProfileTime sets the "load_user_profile_time" field.
func (m *AppUserMutation) SetLoadUserProfileTime(u uint64) {
	m.load_user_profile_time = &u
	m.addload_user_profile_time = nil
}

// LoadUserProfileTime returns the value of the "load_user_profile_time" field in the mutation.
func (m *AppUserMutation) LoadUserProfileTime() (r uint64, exists bool) {
	v := m.load_user_profile_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLoadUserProfileTime returns the old "load_user_profile_time" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldLoadUserProfileTime(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLoadUserProfileTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLoadUserProfileTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoadUserProfileTime: %w", err)
	}
	return oldValue.LoadUserProfileTime, nil
}

// AddLoadUserProfileTime adds u to the "load_user_profile_time" field.
func (m *AppUserMutation) AddLoadUserProfileTime(u uint64) {
	if m.addload_user_profile_time != nil {
		*m.addload_user_profile_time += u
	} else {
		m.addload_user_profile_time = &u
	}
}

// AddedLoadUserProfileTime returns the value that was added to the "load_user_profile_time" field in this mutation.
func (m *AppUserMutation) AddedLoadUserProfileTime() (r uint64, exists bool) {
	v := m.addload_user_profile_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoadUserProfileTime resets all changes to the "load_user_profile_time" field.
func (m *AppUserMutation) ResetLoadUserProfileTime() {
	m.load_user_profile_time = nil
	m.addload_user_profile_time = nil
}

// SetLastLoginTime sets the "last_login_time" field.
func (m *AppUserMutation) SetLastLoginTime(u uint64) {
	m.last_login_time = &u
	m.addlast_login_time = nil
}

// LastLoginTime returns the value of the "last_login_time" field in the mutation.
func (m *AppUserMutation) LastLoginTime() (r uint64, exists bool) {
	v := m.last_login_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginTime returns the old "last_login_time" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldLastLoginTime(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastLoginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastLoginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginTime: %w", err)
	}
	return oldValue.LastLoginTime, nil
}

// AddLastLoginTime adds u to the "last_login_time" field.
func (m *AppUserMutation) AddLastLoginTime(u uint64) {
	if m.addlast_login_time != nil {
		*m.addlast_login_time += u
	} else {
		m.addlast_login_time = &u
	}
}

// AddedLastLoginTime returns the value that was added to the "last_login_time" field in this mutation.
func (m *AppUserMutation) AddedLastLoginTime() (r uint64, exists bool) {
	v := m.addlast_login_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastLoginTime resets all changes to the "last_login_time" field.
func (m *AppUserMutation) ResetLastLoginTime() {
	m.last_login_time = nil
	m.addlast_login_time = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppUserMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppUserMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppUserMutation) AppIDs() (ids []uint64) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppUserMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *AppUserMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AppUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AppUserMutation) UserIDs() (ids []uint64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AppUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AppUserMutation builder.
func (m *AppUserMutation) Where(ps ...predicate.AppUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppUser).
func (m *AppUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.create_time != nil {
		fields = append(fields, appuser.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, appuser.FieldUpdateTime)
	}
	if m.app != nil {
		fields = append(fields, appuser.FieldAppID)
	}
	if m.user != nil {
		fields = append(fields, appuser.FieldUserID)
	}
	if m.open_id != nil {
		fields = append(fields, appuser.FieldOpenID)
	}
	if m.unionid != nil {
		fields = append(fields, appuser.FieldUnionid)
	}
	if m.session_key != nil {
		fields = append(fields, appuser.FieldSessionKey)
	}
	if m.is_load_user_profile != nil {
		fields = append(fields, appuser.FieldIsLoadUserProfile)
	}
	if m.nickname != nil {
		fields = append(fields, appuser.FieldNickname)
	}
	if m.avatar != nil {
		fields = append(fields, appuser.FieldAvatar)
	}
	if m.avatar_url != nil {
		fields = append(fields, appuser.FieldAvatarURL)
	}
	if m.gender != nil {
		fields = append(fields, appuser.FieldGender)
	}
	if m.county != nil {
		fields = append(fields, appuser.FieldCounty)
	}
	if m.country_code != nil {
		fields = append(fields, appuser.FieldCountryCode)
	}
	if m.province != nil {
		fields = append(fields, appuser.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, appuser.FieldCity)
	}
	if m.language != nil {
		fields = append(fields, appuser.FieldLanguage)
	}
	if m.phone_number != nil {
		fields = append(fields, appuser.FieldPhoneNumber)
	}
	if m.pure_phone_number != nil {
		fields = append(fields, appuser.FieldPurePhoneNumber)
	}
	if m.watermark != nil {
		fields = append(fields, appuser.FieldWatermark)
	}
	if m.load_user_profile_time != nil {
		fields = append(fields, appuser.FieldLoadUserProfileTime)
	}
	if m.last_login_time != nil {
		fields = append(fields, appuser.FieldLastLoginTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appuser.FieldCreateTime:
		return m.CreateTime()
	case appuser.FieldUpdateTime:
		return m.UpdateTime()
	case appuser.FieldAppID:
		return m.AppID()
	case appuser.FieldUserID:
		return m.UserID()
	case appuser.FieldOpenID:
		return m.OpenID()
	case appuser.FieldUnionid:
		return m.Unionid()
	case appuser.FieldSessionKey:
		return m.SessionKey()
	case appuser.FieldIsLoadUserProfile:
		return m.IsLoadUserProfile()
	case appuser.FieldNickname:
		return m.Nickname()
	case appuser.FieldAvatar:
		return m.Avatar()
	case appuser.FieldAvatarURL:
		return m.AvatarURL()
	case appuser.FieldGender:
		return m.Gender()
	case appuser.FieldCounty:
		return m.County()
	case appuser.FieldCountryCode:
		return m.CountryCode()
	case appuser.FieldProvince:
		return m.Province()
	case appuser.FieldCity:
		return m.City()
	case appuser.FieldLanguage:
		return m.Language()
	case appuser.FieldPhoneNumber:
		return m.PhoneNumber()
	case appuser.FieldPurePhoneNumber:
		return m.PurePhoneNumber()
	case appuser.FieldWatermark:
		return m.Watermark()
	case appuser.FieldLoadUserProfileTime:
		return m.LoadUserProfileTime()
	case appuser.FieldLastLoginTime:
		return m.LastLoginTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appuser.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case appuser.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case appuser.FieldAppID:
		return m.OldAppID(ctx)
	case appuser.FieldUserID:
		return m.OldUserID(ctx)
	case appuser.FieldOpenID:
		return m.OldOpenID(ctx)
	case appuser.FieldUnionid:
		return m.OldUnionid(ctx)
	case appuser.FieldSessionKey:
		return m.OldSessionKey(ctx)
	case appuser.FieldIsLoadUserProfile:
		return m.OldIsLoadUserProfile(ctx)
	case appuser.FieldNickname:
		return m.OldNickname(ctx)
	case appuser.FieldAvatar:
		return m.OldAvatar(ctx)
	case appuser.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case appuser.FieldGender:
		return m.OldGender(ctx)
	case appuser.FieldCounty:
		return m.OldCounty(ctx)
	case appuser.FieldCountryCode:
		return m.OldCountryCode(ctx)
	case appuser.FieldProvince:
		return m.OldProvince(ctx)
	case appuser.FieldCity:
		return m.OldCity(ctx)
	case appuser.FieldLanguage:
		return m.OldLanguage(ctx)
	case appuser.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case appuser.FieldPurePhoneNumber:
		return m.OldPurePhoneNumber(ctx)
	case appuser.FieldWatermark:
		return m.OldWatermark(ctx)
	case appuser.FieldLoadUserProfileTime:
		return m.OldLoadUserProfileTime(ctx)
	case appuser.FieldLastLoginTime:
		return m.OldLastLoginTime(ctx)
	}
	return nil, fmt.Errorf("unknown AppUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appuser.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case appuser.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case appuser.FieldAppID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appuser.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appuser.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case appuser.FieldUnionid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnionid(v)
		return nil
	case appuser.FieldSessionKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionKey(v)
		return nil
	case appuser.FieldIsLoadUserProfile:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLoadUserProfile(v)
		return nil
	case appuser.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case appuser.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case appuser.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case appuser.FieldGender:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case appuser.FieldCounty:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCounty(v)
		return nil
	case appuser.FieldCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryCode(v)
		return nil
	case appuser.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case appuser.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case appuser.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case appuser.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case appuser.FieldPurePhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurePhoneNumber(v)
		return nil
	case appuser.FieldWatermark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWatermark(v)
		return nil
	case appuser.FieldLoadUserProfileTime:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoadUserProfileTime(v)
		return nil
	case appuser.FieldLastLoginTime:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginTime(v)
		return nil
	}
	return fmt.Errorf("unknown AppUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_time != nil {
		fields = append(fields, appuser.FieldCreateTime)
	}
	if m.addupdate_time != nil {
		fields = append(fields, appuser.FieldUpdateTime)
	}
	if m.addgender != nil {
		fields = append(fields, appuser.FieldGender)
	}
	if m.addload_user_profile_time != nil {
		fields = append(fields, appuser.FieldLoadUserProfileTime)
	}
	if m.addlast_login_time != nil {
		fields = append(fields, appuser.FieldLastLoginTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appuser.FieldCreateTime:
		return m.AddedCreateTime()
	case appuser.FieldUpdateTime:
		return m.AddedUpdateTime()
	case appuser.FieldGender:
		return m.AddedGender()
	case appuser.FieldLoadUserProfileTime:
		return m.AddedLoadUserProfileTime()
	case appuser.FieldLastLoginTime:
		return m.AddedLastLoginTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appuser.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case appuser.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	case appuser.FieldGender:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case appuser.FieldLoadUserProfileTime:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoadUserProfileTime(v)
		return nil
	case appuser.FieldLastLoginTime:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastLoginTime(v)
		return nil
	}
	return fmt.Errorf("unknown AppUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserMutation) ResetField(name string) error {
	switch name {
	case appuser.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case appuser.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case appuser.FieldAppID:
		m.ResetAppID()
		return nil
	case appuser.FieldUserID:
		m.ResetUserID()
		return nil
	case appuser.FieldOpenID:
		m.ResetOpenID()
		return nil
	case appuser.FieldUnionid:
		m.ResetUnionid()
		return nil
	case appuser.FieldSessionKey:
		m.ResetSessionKey()
		return nil
	case appuser.FieldIsLoadUserProfile:
		m.ResetIsLoadUserProfile()
		return nil
	case appuser.FieldNickname:
		m.ResetNickname()
		return nil
	case appuser.FieldAvatar:
		m.ResetAvatar()
		return nil
	case appuser.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case appuser.FieldGender:
		m.ResetGender()
		return nil
	case appuser.FieldCounty:
		m.ResetCounty()
		return nil
	case appuser.FieldCountryCode:
		m.ResetCountryCode()
		return nil
	case appuser.FieldProvince:
		m.ResetProvince()
		return nil
	case appuser.FieldCity:
		m.ResetCity()
		return nil
	case appuser.FieldLanguage:
		m.ResetLanguage()
		return nil
	case appuser.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case appuser.FieldPurePhoneNumber:
		m.ResetPurePhoneNumber()
		return nil
	case appuser.FieldWatermark:
		m.ResetWatermark()
		return nil
	case appuser.FieldLoadUserProfileTime:
		m.ResetLoadUserProfileTime()
		return nil
	case appuser.FieldLastLoginTime:
		m.ResetLastLoginTime()
		return nil
	}
	return fmt.Errorf("unknown AppUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, appuser.EdgeApp)
	}
	if m.user != nil {
		edges = append(edges, appuser.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appuser.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case appuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, appuser.EdgeApp)
	}
	if m.cleareduser {
		edges = append(edges, appuser.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserMutation) EdgeCleared(name string) bool {
	switch name {
	case appuser.EdgeApp:
		return m.clearedapp
	case appuser.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserMutation) ClearEdge(name string) error {
	switch name {
	case appuser.EdgeApp:
		m.ClearApp()
		return nil
	case appuser.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AppUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserMutation) ResetEdge(name string) error {
	switch name {
	case appuser.EdgeApp:
		m.ResetApp()
		return nil
	case appuser.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AppUser edge %s", name)
}

// AppUserLoginLogMutation represents an operation that mutates the AppUserLoginLog nodes in the graph.
type AppUserLoginLogMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	create_time      *int64
	addcreate_time   *int64
	login_type_id    *uint
	addlogin_type_id *uint
	ip               *string
	content          *string
	status           *uint
	addstatus        *uint
	clearedFields    map[string]struct{}
	app              *uint64
	clearedapp       bool
	appUser          *uint64
	clearedappUser   bool
	user             *uint64
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*AppUserLoginLog, error)
	predicates       []predicate.AppUserLoginLog
}

var _ ent.Mutation = (*AppUserLoginLogMutation)(nil)

// appuserloginlogOption allows management of the mutation configuration using functional options.
type appuserloginlogOption func(*AppUserLoginLogMutation)

// newAppUserLoginLogMutation creates new mutation for the AppUserLoginLog entity.
func newAppUserLoginLogMutation(c config, op Op, opts ...appuserloginlogOption) *AppUserLoginLogMutation {
	m := &AppUserLoginLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUserLoginLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserLoginLogID sets the ID field of the mutation.
func withAppUserLoginLogID(id uint64) appuserloginlogOption {
	return func(m *AppUserLoginLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUserLoginLog
		)
		m.oldValue = func(ctx context.Context) (*AppUserLoginLog, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUserLoginLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUserLoginLog sets the old AppUserLoginLog of the mutation.
func withAppUserLoginLog(node *AppUserLoginLog) appuserloginlogOption {
	return func(m *AppUserLoginLogMutation) {
		m.oldValue = func(context.Context) (*AppUserLoginLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserLoginLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserLoginLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUserLoginLog entities.
func (m *AppUserLoginLogMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserLoginLogMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *AppUserLoginLogMutation) SetCreateTime(i int64) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AppUserLoginLogMutation) CreateTime() (r int64, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AppUserLoginLog entity.
// If the AppUserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserLoginLogMutation) OldCreateTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *AppUserLoginLogMutation) AddCreateTime(i int64) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *AppUserLoginLogMutation) AddedCreateTime() (r int64, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AppUserLoginLogMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserLoginLogMutation) SetAppID(u uint64) {
	m.app = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserLoginLogMutation) AppID() (r uint64, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUserLoginLog entity.
// If the AppUserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserLoginLogMutation) OldAppID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserLoginLogMutation) ResetAppID() {
	m.app = nil
}

// SetAppUserID sets the "app_user_id" field.
func (m *AppUserLoginLogMutation) SetAppUserID(u uint64) {
	m.appUser = &u
}

// AppUserID returns the value of the "app_user_id" field in the mutation.
func (m *AppUserLoginLogMutation) AppUserID() (r uint64, exists bool) {
	v := m.appUser
	if v == nil {
		return
	}
	return *v, true
}

// OldAppUserID returns the old "app_user_id" field's value of the AppUserLoginLog entity.
// If the AppUserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserLoginLogMutation) OldAppUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAppUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAppUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppUserID: %w", err)
	}
	return oldValue.AppUserID, nil
}

// ResetAppUserID resets all changes to the "app_user_id" field.
func (m *AppUserLoginLogMutation) ResetAppUserID() {
	m.appUser = nil
}

// SetUserID sets the "user_id" field.
func (m *AppUserLoginLogMutation) SetUserID(u uint64) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserLoginLogMutation) UserID() (r uint64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUserLoginLog entity.
// If the AppUserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserLoginLogMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserLoginLogMutation) ResetUserID() {
	m.user = nil
}

// SetLoginTypeID sets the "login_type_id" field.
func (m *AppUserLoginLogMutation) SetLoginTypeID(u uint) {
	m.login_type_id = &u
	m.addlogin_type_id = nil
}

// LoginTypeID returns the value of the "login_type_id" field in the mutation.
func (m *AppUserLoginLogMutation) LoginTypeID() (r uint, exists bool) {
	v := m.login_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginTypeID returns the old "login_type_id" field's value of the AppUserLoginLog entity.
// If the AppUserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserLoginLogMutation) OldLoginTypeID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLoginTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLoginTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginTypeID: %w", err)
	}
	return oldValue.LoginTypeID, nil
}

// AddLoginTypeID adds u to the "login_type_id" field.
func (m *AppUserLoginLogMutation) AddLoginTypeID(u uint) {
	if m.addlogin_type_id != nil {
		*m.addlogin_type_id += u
	} else {
		m.addlogin_type_id = &u
	}
}

// AddedLoginTypeID returns the value that was added to the "login_type_id" field in this mutation.
func (m *AppUserLoginLogMutation) AddedLoginTypeID() (r uint, exists bool) {
	v := m.addlogin_type_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoginTypeID resets all changes to the "login_type_id" field.
func (m *AppUserLoginLogMutation) ResetLoginTypeID() {
	m.login_type_id = nil
	m.addlogin_type_id = nil
}

// SetIP sets the "ip" field.
func (m *AppUserLoginLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AppUserLoginLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the AppUserLoginLog entity.
// If the AppUserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserLoginLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *AppUserLoginLogMutation) ResetIP() {
	m.ip = nil
}

// SetContent sets the "content" field.
func (m *AppUserLoginLogMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *AppUserLoginLogMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the AppUserLoginLog entity.
// If the AppUserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserLoginLogMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *AppUserLoginLogMutation) ClearContent() {
	m.content = nil
	m.clearedFields[appuserloginlog.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *AppUserLoginLogMutation) ContentCleared() bool {
	_, ok := m.clearedFields[appuserloginlog.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *AppUserLoginLogMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, appuserloginlog.FieldContent)
}

// SetStatus sets the "status" field.
func (m *AppUserLoginLogMutation) SetStatus(u uint) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AppUserLoginLogMutation) Status() (r uint, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AppUserLoginLog entity.
// If the AppUserLoginLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserLoginLogMutation) OldStatus(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *AppUserLoginLogMutation) AddStatus(u uint) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AppUserLoginLogMutation) AddedStatus() (r uint, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AppUserLoginLogMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppUserLoginLogMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppUserLoginLogMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppUserLoginLogMutation) AppIDs() (ids []uint64) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppUserLoginLogMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// ClearAppUser clears the "appUser" edge to the AppUser entity.
func (m *AppUserLoginLogMutation) ClearAppUser() {
	m.clearedappUser = true
}

// AppUserCleared reports if the "appUser" edge to the AppUser entity was cleared.
func (m *AppUserLoginLogMutation) AppUserCleared() bool {
	return m.clearedappUser
}

// AppUserIDs returns the "appUser" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppUserID instead. It exists only for internal usage by the builders.
func (m *AppUserLoginLogMutation) AppUserIDs() (ids []uint64) {
	if id := m.appUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppUser resets all changes to the "appUser" edge.
func (m *AppUserLoginLogMutation) ResetAppUser() {
	m.appUser = nil
	m.clearedappUser = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *AppUserLoginLogMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AppUserLoginLogMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AppUserLoginLogMutation) UserIDs() (ids []uint64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AppUserLoginLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AppUserLoginLogMutation builder.
func (m *AppUserLoginLogMutation) Where(ps ...predicate.AppUserLoginLog) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppUserLoginLogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppUserLoginLog).
func (m *AppUserLoginLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserLoginLogMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, appuserloginlog.FieldCreateTime)
	}
	if m.app != nil {
		fields = append(fields, appuserloginlog.FieldAppID)
	}
	if m.appUser != nil {
		fields = append(fields, appuserloginlog.FieldAppUserID)
	}
	if m.user != nil {
		fields = append(fields, appuserloginlog.FieldUserID)
	}
	if m.login_type_id != nil {
		fields = append(fields, appuserloginlog.FieldLoginTypeID)
	}
	if m.ip != nil {
		fields = append(fields, appuserloginlog.FieldIP)
	}
	if m.content != nil {
		fields = append(fields, appuserloginlog.FieldContent)
	}
	if m.status != nil {
		fields = append(fields, appuserloginlog.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserLoginLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appuserloginlog.FieldCreateTime:
		return m.CreateTime()
	case appuserloginlog.FieldAppID:
		return m.AppID()
	case appuserloginlog.FieldAppUserID:
		return m.AppUserID()
	case appuserloginlog.FieldUserID:
		return m.UserID()
	case appuserloginlog.FieldLoginTypeID:
		return m.LoginTypeID()
	case appuserloginlog.FieldIP:
		return m.IP()
	case appuserloginlog.FieldContent:
		return m.Content()
	case appuserloginlog.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserLoginLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appuserloginlog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case appuserloginlog.FieldAppID:
		return m.OldAppID(ctx)
	case appuserloginlog.FieldAppUserID:
		return m.OldAppUserID(ctx)
	case appuserloginlog.FieldUserID:
		return m.OldUserID(ctx)
	case appuserloginlog.FieldLoginTypeID:
		return m.OldLoginTypeID(ctx)
	case appuserloginlog.FieldIP:
		return m.OldIP(ctx)
	case appuserloginlog.FieldContent:
		return m.OldContent(ctx)
	case appuserloginlog.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown AppUserLoginLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserLoginLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appuserloginlog.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case appuserloginlog.FieldAppID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appuserloginlog.FieldAppUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppUserID(v)
		return nil
	case appuserloginlog.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appuserloginlog.FieldLoginTypeID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginTypeID(v)
		return nil
	case appuserloginlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case appuserloginlog.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case appuserloginlog.FieldStatus:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserLoginLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserLoginLogMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_time != nil {
		fields = append(fields, appuserloginlog.FieldCreateTime)
	}
	if m.addlogin_type_id != nil {
		fields = append(fields, appuserloginlog.FieldLoginTypeID)
	}
	if m.addstatus != nil {
		fields = append(fields, appuserloginlog.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserLoginLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appuserloginlog.FieldCreateTime:
		return m.AddedCreateTime()
	case appuserloginlog.FieldLoginTypeID:
		return m.AddedLoginTypeID()
	case appuserloginlog.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserLoginLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appuserloginlog.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case appuserloginlog.FieldLoginTypeID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoginTypeID(v)
		return nil
	case appuserloginlog.FieldStatus:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserLoginLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserLoginLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appuserloginlog.FieldContent) {
		fields = append(fields, appuserloginlog.FieldContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserLoginLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserLoginLogMutation) ClearField(name string) error {
	switch name {
	case appuserloginlog.FieldContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown AppUserLoginLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserLoginLogMutation) ResetField(name string) error {
	switch name {
	case appuserloginlog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case appuserloginlog.FieldAppID:
		m.ResetAppID()
		return nil
	case appuserloginlog.FieldAppUserID:
		m.ResetAppUserID()
		return nil
	case appuserloginlog.FieldUserID:
		m.ResetUserID()
		return nil
	case appuserloginlog.FieldLoginTypeID:
		m.ResetLoginTypeID()
		return nil
	case appuserloginlog.FieldIP:
		m.ResetIP()
		return nil
	case appuserloginlog.FieldContent:
		m.ResetContent()
		return nil
	case appuserloginlog.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown AppUserLoginLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserLoginLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.app != nil {
		edges = append(edges, appuserloginlog.EdgeApp)
	}
	if m.appUser != nil {
		edges = append(edges, appuserloginlog.EdgeAppUser)
	}
	if m.user != nil {
		edges = append(edges, appuserloginlog.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserLoginLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appuserloginlog.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case appuserloginlog.EdgeAppUser:
		if id := m.appUser; id != nil {
			return []ent.Value{*id}
		}
	case appuserloginlog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserLoginLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserLoginLogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserLoginLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapp {
		edges = append(edges, appuserloginlog.EdgeApp)
	}
	if m.clearedappUser {
		edges = append(edges, appuserloginlog.EdgeAppUser)
	}
	if m.cleareduser {
		edges = append(edges, appuserloginlog.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserLoginLogMutation) EdgeCleared(name string) bool {
	switch name {
	case appuserloginlog.EdgeApp:
		return m.clearedapp
	case appuserloginlog.EdgeAppUser:
		return m.clearedappUser
	case appuserloginlog.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserLoginLogMutation) ClearEdge(name string) error {
	switch name {
	case appuserloginlog.EdgeApp:
		m.ClearApp()
		return nil
	case appuserloginlog.EdgeAppUser:
		m.ClearAppUser()
		return nil
	case appuserloginlog.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AppUserLoginLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserLoginLogMutation) ResetEdge(name string) error {
	switch name {
	case appuserloginlog.EdgeApp:
		m.ResetApp()
		return nil
	case appuserloginlog.EdgeAppUser:
		m.ResetAppUser()
		return nil
	case appuserloginlog.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AppUserLoginLog edge %s", name)
}

// AppUserTokenMutation represents an operation that mutates the AppUserToken nodes in the graph.
type AppUserTokenMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	create_time    *int64
	addcreate_time *int64
	client_version *string
	uuid           *uuid.UUID
	ip             *string
	expire_time    *uint64
	addexpire_time *uint64
	clearedFields  map[string]struct{}
	app            *uint64
	clearedapp     bool
	appUser        *uint64
	clearedappUser bool
	user           *uint64
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*AppUserToken, error)
	predicates     []predicate.AppUserToken
}

var _ ent.Mutation = (*AppUserTokenMutation)(nil)

// appusertokenOption allows management of the mutation configuration using functional options.
type appusertokenOption func(*AppUserTokenMutation)

// newAppUserTokenMutation creates new mutation for the AppUserToken entity.
func newAppUserTokenMutation(c config, op Op, opts ...appusertokenOption) *AppUserTokenMutation {
	m := &AppUserTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUserToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserTokenID sets the ID field of the mutation.
func withAppUserTokenID(id uint64) appusertokenOption {
	return func(m *AppUserTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUserToken
		)
		m.oldValue = func(ctx context.Context) (*AppUserToken, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUserToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUserToken sets the old AppUserToken of the mutation.
func withAppUserToken(node *AppUserToken) appusertokenOption {
	return func(m *AppUserTokenMutation) {
		m.oldValue = func(context.Context) (*AppUserToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUserToken entities.
func (m *AppUserTokenMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserTokenMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *AppUserTokenMutation) SetCreateTime(i int64) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AppUserTokenMutation) CreateTime() (r int64, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AppUserToken entity.
// If the AppUserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserTokenMutation) OldCreateTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *AppUserTokenMutation) AddCreateTime(i int64) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *AppUserTokenMutation) AddedCreateTime() (r int64, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AppUserTokenMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
}

// SetAppID sets the "app_id" field.
func (m *AppUserTokenMutation) SetAppID(u uint64) {
	m.app = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserTokenMutation) AppID() (r uint64, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUserToken entity.
// If the AppUserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserTokenMutation) OldAppID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserTokenMutation) ResetAppID() {
	m.app = nil
}

// SetAppUserID sets the "app_user_id" field.
func (m *AppUserTokenMutation) SetAppUserID(u uint64) {
	m.appUser = &u
}

// AppUserID returns the value of the "app_user_id" field in the mutation.
func (m *AppUserTokenMutation) AppUserID() (r uint64, exists bool) {
	v := m.appUser
	if v == nil {
		return
	}
	return *v, true
}

// OldAppUserID returns the old "app_user_id" field's value of the AppUserToken entity.
// If the AppUserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserTokenMutation) OldAppUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAppUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAppUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppUserID: %w", err)
	}
	return oldValue.AppUserID, nil
}

// ResetAppUserID resets all changes to the "app_user_id" field.
func (m *AppUserTokenMutation) ResetAppUserID() {
	m.appUser = nil
}

// SetUserID sets the "user_id" field.
func (m *AppUserTokenMutation) SetUserID(u uint64) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppUserTokenMutation) UserID() (r uint64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppUserToken entity.
// If the AppUserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserTokenMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppUserTokenMutation) ResetUserID() {
	m.user = nil
}

// SetClientVersion sets the "client_version" field.
func (m *AppUserTokenMutation) SetClientVersion(s string) {
	m.client_version = &s
}

// ClientVersion returns the value of the "client_version" field in the mutation.
func (m *AppUserTokenMutation) ClientVersion() (r string, exists bool) {
	v := m.client_version
	if v == nil {
		return
	}
	return *v, true
}

// OldClientVersion returns the old "client_version" field's value of the AppUserToken entity.
// If the AppUserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserTokenMutation) OldClientVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClientVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClientVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientVersion: %w", err)
	}
	return oldValue.ClientVersion, nil
}

// ResetClientVersion resets all changes to the "client_version" field.
func (m *AppUserTokenMutation) ResetClientVersion() {
	m.client_version = nil
}

// SetUUID sets the "uuid" field.
func (m *AppUserTokenMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *AppUserTokenMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the AppUserToken entity.
// If the AppUserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserTokenMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *AppUserTokenMutation) ResetUUID() {
	m.uuid = nil
}

// SetIP sets the "ip" field.
func (m *AppUserTokenMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AppUserTokenMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the AppUserToken entity.
// If the AppUserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserTokenMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *AppUserTokenMutation) ResetIP() {
	m.ip = nil
}

// SetExpireTime sets the "expire_time" field.
func (m *AppUserTokenMutation) SetExpireTime(u uint64) {
	m.expire_time = &u
	m.addexpire_time = nil
}

// ExpireTime returns the value of the "expire_time" field in the mutation.
func (m *AppUserTokenMutation) ExpireTime() (r uint64, exists bool) {
	v := m.expire_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireTime returns the old "expire_time" field's value of the AppUserToken entity.
// If the AppUserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserTokenMutation) OldExpireTime(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpireTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpireTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireTime: %w", err)
	}
	return oldValue.ExpireTime, nil
}

// AddExpireTime adds u to the "expire_time" field.
func (m *AppUserTokenMutation) AddExpireTime(u uint64) {
	if m.addexpire_time != nil {
		*m.addexpire_time += u
	} else {
		m.addexpire_time = &u
	}
}

// AddedExpireTime returns the value that was added to the "expire_time" field in this mutation.
func (m *AppUserTokenMutation) AddedExpireTime() (r uint64, exists bool) {
	v := m.addexpire_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpireTime resets all changes to the "expire_time" field.
func (m *AppUserTokenMutation) ResetExpireTime() {
	m.expire_time = nil
	m.addexpire_time = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppUserTokenMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppUserTokenMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppUserTokenMutation) AppIDs() (ids []uint64) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppUserTokenMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// ClearAppUser clears the "appUser" edge to the AppUser entity.
func (m *AppUserTokenMutation) ClearAppUser() {
	m.clearedappUser = true
}

// AppUserCleared reports if the "appUser" edge to the AppUser entity was cleared.
func (m *AppUserTokenMutation) AppUserCleared() bool {
	return m.clearedappUser
}

// AppUserIDs returns the "appUser" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppUserID instead. It exists only for internal usage by the builders.
func (m *AppUserTokenMutation) AppUserIDs() (ids []uint64) {
	if id := m.appUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppUser resets all changes to the "appUser" edge.
func (m *AppUserTokenMutation) ResetAppUser() {
	m.appUser = nil
	m.clearedappUser = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *AppUserTokenMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AppUserTokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AppUserTokenMutation) UserIDs() (ids []uint64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AppUserTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AppUserTokenMutation builder.
func (m *AppUserTokenMutation) Where(ps ...predicate.AppUserToken) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppUserTokenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AppUserToken).
func (m *AppUserTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserTokenMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, appusertoken.FieldCreateTime)
	}
	if m.app != nil {
		fields = append(fields, appusertoken.FieldAppID)
	}
	if m.appUser != nil {
		fields = append(fields, appusertoken.FieldAppUserID)
	}
	if m.user != nil {
		fields = append(fields, appusertoken.FieldUserID)
	}
	if m.client_version != nil {
		fields = append(fields, appusertoken.FieldClientVersion)
	}
	if m.uuid != nil {
		fields = append(fields, appusertoken.FieldUUID)
	}
	if m.ip != nil {
		fields = append(fields, appusertoken.FieldIP)
	}
	if m.expire_time != nil {
		fields = append(fields, appusertoken.FieldExpireTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appusertoken.FieldCreateTime:
		return m.CreateTime()
	case appusertoken.FieldAppID:
		return m.AppID()
	case appusertoken.FieldAppUserID:
		return m.AppUserID()
	case appusertoken.FieldUserID:
		return m.UserID()
	case appusertoken.FieldClientVersion:
		return m.ClientVersion()
	case appusertoken.FieldUUID:
		return m.UUID()
	case appusertoken.FieldIP:
		return m.IP()
	case appusertoken.FieldExpireTime:
		return m.ExpireTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appusertoken.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case appusertoken.FieldAppID:
		return m.OldAppID(ctx)
	case appusertoken.FieldAppUserID:
		return m.OldAppUserID(ctx)
	case appusertoken.FieldUserID:
		return m.OldUserID(ctx)
	case appusertoken.FieldClientVersion:
		return m.OldClientVersion(ctx)
	case appusertoken.FieldUUID:
		return m.OldUUID(ctx)
	case appusertoken.FieldIP:
		return m.OldIP(ctx)
	case appusertoken.FieldExpireTime:
		return m.OldExpireTime(ctx)
	}
	return nil, fmt.Errorf("unknown AppUserToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appusertoken.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case appusertoken.FieldAppID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appusertoken.FieldAppUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppUserID(v)
		return nil
	case appusertoken.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appusertoken.FieldClientVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientVersion(v)
		return nil
	case appusertoken.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case appusertoken.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case appusertoken.FieldExpireTime:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireTime(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserTokenMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_time != nil {
		fields = append(fields, appusertoken.FieldCreateTime)
	}
	if m.addexpire_time != nil {
		fields = append(fields, appusertoken.FieldExpireTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appusertoken.FieldCreateTime:
		return m.AddedCreateTime()
	case appusertoken.FieldExpireTime:
		return m.AddedExpireTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appusertoken.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case appusertoken.FieldExpireTime:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpireTime(v)
		return nil
	}
	return fmt.Errorf("unknown AppUserToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppUserToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserTokenMutation) ResetField(name string) error {
	switch name {
	case appusertoken.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case appusertoken.FieldAppID:
		m.ResetAppID()
		return nil
	case appusertoken.FieldAppUserID:
		m.ResetAppUserID()
		return nil
	case appusertoken.FieldUserID:
		m.ResetUserID()
		return nil
	case appusertoken.FieldClientVersion:
		m.ResetClientVersion()
		return nil
	case appusertoken.FieldUUID:
		m.ResetUUID()
		return nil
	case appusertoken.FieldIP:
		m.ResetIP()
		return nil
	case appusertoken.FieldExpireTime:
		m.ResetExpireTime()
		return nil
	}
	return fmt.Errorf("unknown AppUserToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.app != nil {
		edges = append(edges, appusertoken.EdgeApp)
	}
	if m.appUser != nil {
		edges = append(edges, appusertoken.EdgeAppUser)
	}
	if m.user != nil {
		edges = append(edges, appusertoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appusertoken.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case appusertoken.EdgeAppUser:
		if id := m.appUser; id != nil {
			return []ent.Value{*id}
		}
	case appusertoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserTokenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapp {
		edges = append(edges, appusertoken.EdgeApp)
	}
	if m.clearedappUser {
		edges = append(edges, appusertoken.EdgeAppUser)
	}
	if m.cleareduser {
		edges = append(edges, appusertoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case appusertoken.EdgeApp:
		return m.clearedapp
	case appusertoken.EdgeAppUser:
		return m.clearedappUser
	case appusertoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserTokenMutation) ClearEdge(name string) error {
	switch name {
	case appusertoken.EdgeApp:
		m.ClearApp()
		return nil
	case appusertoken.EdgeAppUser:
		m.ClearAppUser()
		return nil
	case appusertoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AppUserToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserTokenMutation) ResetEdge(name string) error {
	switch name {
	case appusertoken.EdgeApp:
		m.ResetApp()
		return nil
	case appusertoken.EdgeAppUser:
		m.ResetAppUser()
		return nil
	case appusertoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AppUserToken edge %s", name)
}

// AuthAssgimentMutation represents an operation that mutates the AuthAssgiment nodes in the graph.
type AuthAssgimentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthAssgiment, error)
	predicates    []predicate.AuthAssgiment
}

var _ ent.Mutation = (*AuthAssgimentMutation)(nil)

// authassgimentOption allows management of the mutation configuration using functional options.
type authassgimentOption func(*AuthAssgimentMutation)

// newAuthAssgimentMutation creates new mutation for the AuthAssgiment entity.
func newAuthAssgimentMutation(c config, op Op, opts ...authassgimentOption) *AuthAssgimentMutation {
	m := &AuthAssgimentMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthAssgiment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthAssgimentID sets the ID field of the mutation.
func withAuthAssgimentID(id int) authassgimentOption {
	return func(m *AuthAssgimentMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthAssgiment
		)
		m.oldValue = func(ctx context.Context) (*AuthAssgiment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthAssgiment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthAssgiment sets the old AuthAssgiment of the mutation.
func withAuthAssgiment(node *AuthAssgiment) authassgimentOption {
	return func(m *AuthAssgimentMutation) {
		m.oldValue = func(context.Context) (*AuthAssgiment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthAssgimentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthAssgimentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthAssgimentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Where appends a list predicates to the AuthAssgimentMutation builder.
func (m *AuthAssgimentMutation) Where(ps ...predicate.AuthAssgiment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthAssgimentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthAssgiment).
func (m *AuthAssgimentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthAssgimentMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthAssgimentMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthAssgimentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown AuthAssgiment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthAssgimentMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthAssgiment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthAssgimentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthAssgimentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthAssgimentMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown AuthAssgiment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthAssgimentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthAssgimentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthAssgimentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthAssgiment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthAssgimentMutation) ResetField(name string) error {
	return fmt.Errorf("unknown AuthAssgiment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthAssgimentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthAssgimentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthAssgimentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthAssgimentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthAssgimentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthAssgimentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthAssgimentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthAssgiment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthAssgimentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthAssgiment edge %s", name)
}

// AuthItemMutation represents an operation that mutates the AuthItem nodes in the graph.
type AuthItemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthItem, error)
	predicates    []predicate.AuthItem
}

var _ ent.Mutation = (*AuthItemMutation)(nil)

// authitemOption allows management of the mutation configuration using functional options.
type authitemOption func(*AuthItemMutation)

// newAuthItemMutation creates new mutation for the AuthItem entity.
func newAuthItemMutation(c config, op Op, opts ...authitemOption) *AuthItemMutation {
	m := &AuthItemMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthItemID sets the ID field of the mutation.
func withAuthItemID(id int) authitemOption {
	return func(m *AuthItemMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthItem
		)
		m.oldValue = func(ctx context.Context) (*AuthItem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthItem sets the old AuthItem of the mutation.
func withAuthItem(node *AuthItem) authitemOption {
	return func(m *AuthItemMutation) {
		m.oldValue = func(context.Context) (*AuthItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Where appends a list predicates to the AuthItemMutation builder.
func (m *AuthItemMutation) Where(ps ...predicate.AuthItem) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthItem).
func (m *AuthItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthItemMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthItemMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown AuthItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthItemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthItemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthItemMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown AuthItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthItemMutation) ResetField(name string) error {
	return fmt.Errorf("unknown AuthItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthItem edge %s", name)
}

// AuthItemChildMutation represents an operation that mutates the AuthItemChild nodes in the graph.
type AuthItemChildMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthItemChild, error)
	predicates    []predicate.AuthItemChild
}

var _ ent.Mutation = (*AuthItemChildMutation)(nil)

// authitemchildOption allows management of the mutation configuration using functional options.
type authitemchildOption func(*AuthItemChildMutation)

// newAuthItemChildMutation creates new mutation for the AuthItemChild entity.
func newAuthItemChildMutation(c config, op Op, opts ...authitemchildOption) *AuthItemChildMutation {
	m := &AuthItemChildMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthItemChild,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthItemChildID sets the ID field of the mutation.
func withAuthItemChildID(id int) authitemchildOption {
	return func(m *AuthItemChildMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthItemChild
		)
		m.oldValue = func(ctx context.Context) (*AuthItemChild, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthItemChild.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthItemChild sets the old AuthItemChild of the mutation.
func withAuthItemChild(node *AuthItemChild) authitemchildOption {
	return func(m *AuthItemChildMutation) {
		m.oldValue = func(context.Context) (*AuthItemChild, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthItemChildMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthItemChildMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthItemChildMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Where appends a list predicates to the AuthItemChildMutation builder.
func (m *AuthItemChildMutation) Where(ps ...predicate.AuthItemChild) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthItemChildMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthItemChild).
func (m *AuthItemChildMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthItemChildMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthItemChildMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthItemChildMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown AuthItemChild field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthItemChildMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthItemChild field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthItemChildMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthItemChildMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthItemChildMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown AuthItemChild numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthItemChildMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthItemChildMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthItemChildMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthItemChild nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthItemChildMutation) ResetField(name string) error {
	return fmt.Errorf("unknown AuthItemChild field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthItemChildMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthItemChildMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthItemChildMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthItemChildMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthItemChildMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthItemChildMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthItemChildMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthItemChild unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthItemChildMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthItemChild edge %s", name)
}

// AuthRoleMutation represents an operation that mutates the AuthRole nodes in the graph.
type AuthRoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthRole, error)
	predicates    []predicate.AuthRole
}

var _ ent.Mutation = (*AuthRoleMutation)(nil)

// authroleOption allows management of the mutation configuration using functional options.
type authroleOption func(*AuthRoleMutation)

// newAuthRoleMutation creates new mutation for the AuthRole entity.
func newAuthRoleMutation(c config, op Op, opts ...authroleOption) *AuthRoleMutation {
	m := &AuthRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthRoleID sets the ID field of the mutation.
func withAuthRoleID(id int) authroleOption {
	return func(m *AuthRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthRole
		)
		m.oldValue = func(ctx context.Context) (*AuthRole, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthRole sets the old AuthRole of the mutation.
func withAuthRole(node *AuthRole) authroleOption {
	return func(m *AuthRoleMutation) {
		m.oldValue = func(context.Context) (*AuthRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Where appends a list predicates to the AuthRoleMutation builder.
func (m *AuthRoleMutation) Where(ps ...predicate.AuthRole) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthRoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthRole).
func (m *AuthRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthRoleMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthRoleMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown AuthRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRoleMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown AuthRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthRoleMutation) ResetField(name string) error {
	return fmt.Errorf("unknown AuthRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthRoleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthRoleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthRoleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthRoleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthRole edge %s", name)
}

// AuthRuleMutation represents an operation that mutates the AuthRule nodes in the graph.
type AuthRuleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthRule, error)
	predicates    []predicate.AuthRule
}

var _ ent.Mutation = (*AuthRuleMutation)(nil)

// authruleOption allows management of the mutation configuration using functional options.
type authruleOption func(*AuthRuleMutation)

// newAuthRuleMutation creates new mutation for the AuthRule entity.
func newAuthRuleMutation(c config, op Op, opts ...authruleOption) *AuthRuleMutation {
	m := &AuthRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthRuleID sets the ID field of the mutation.
func withAuthRuleID(id int) authruleOption {
	return func(m *AuthRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthRule
		)
		m.oldValue = func(ctx context.Context) (*AuthRule, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthRule sets the old AuthRule of the mutation.
func withAuthRule(node *AuthRule) authruleOption {
	return func(m *AuthRuleMutation) {
		m.oldValue = func(context.Context) (*AuthRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthRuleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Where appends a list predicates to the AuthRuleMutation builder.
func (m *AuthRuleMutation) Where(ps ...predicate.AuthRule) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthRuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthRule).
func (m *AuthRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthRuleMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthRuleMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown AuthRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthRuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthRuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRuleMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown AuthRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthRuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthRuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthRuleMutation) ResetField(name string) error {
	return fmt.Errorf("unknown AuthRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthRuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthRuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthRuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthRuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthRule edge %s", name)
}

// EmailLogMutation represents an operation that mutates the EmailLog nodes in the graph.
type EmailLogMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	create_time    *int64
	addcreate_time *int64
	create_by      *uint64
	addcreate_by   *uint64
	update_time    *int64
	addupdate_time *int64
	update_by      *uint64
	addupdate_by   *uint64
	email          *string
	scope          *string
	type_id        *uint64
	addtype_id     *uint64
	gateway        *string
	ip             *string
	from_name      *string
	from_address   *string
	title          *string
	content        *string
	data           *string
	check_count    *uint8
	addcheck_count *uint8
	status         *uint
	addstatus      *uint
	return_msg     *string
	clearedFields  map[string]struct{}
	app            *uint64
	clearedapp     bool
	done           bool
	oldValue       func(context.Context) (*EmailLog, error)
	predicates     []predicate.EmailLog
}

var _ ent.Mutation = (*EmailLogMutation)(nil)

// emaillogOption allows management of the mutation configuration using functional options.
type emaillogOption func(*EmailLogMutation)

// newEmailLogMutation creates new mutation for the EmailLog entity.
func newEmailLogMutation(c config, op Op, opts ...emaillogOption) *EmailLogMutation {
	m := &EmailLogMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailLogID sets the ID field of the mutation.
func withEmailLogID(id uint64) emaillogOption {
	return func(m *EmailLogMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailLog
		)
		m.oldValue = func(ctx context.Context) (*EmailLog, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailLog sets the old EmailLog of the mutation.
func withEmailLog(node *EmailLog) emaillogOption {
	return func(m *EmailLogMutation) {
		m.oldValue = func(context.Context) (*EmailLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailLog entities.
func (m *EmailLogMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailLogMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *EmailLogMutation) SetCreateTime(i int64) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *EmailLogMutation) CreateTime() (r int64, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldCreateTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *EmailLogMutation) AddCreateTime(i int64) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *EmailLogMutation) AddedCreateTime() (r int64, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *EmailLogMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
}

// SetCreateBy sets the "create_by" field.
func (m *EmailLogMutation) SetCreateBy(u uint64) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *EmailLogMutation) CreateBy() (r uint64, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldCreateBy(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *EmailLogMutation) AddCreateBy(u uint64) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *EmailLogMutation) AddedCreateBy() (r uint64, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *EmailLogMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *EmailLogMutation) SetUpdateTime(i int64) {
	m.update_time = &i
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *EmailLogMutation) UpdateTime() (r int64, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldUpdateTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds i to the "update_time" field.
func (m *EmailLogMutation) AddUpdateTime(i int64) {
	if m.addupdate_time != nil {
		*m.addupdate_time += i
	} else {
		m.addupdate_time = &i
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *EmailLogMutation) AddedUpdateTime() (r int64, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *EmailLogMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
}

// SetUpdateBy sets the "update_by" field.
func (m *EmailLogMutation) SetUpdateBy(u uint64) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *EmailLogMutation) UpdateBy() (r uint64, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldUpdateBy(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *EmailLogMutation) AddUpdateBy(u uint64) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *EmailLogMutation) AddedUpdateBy() (r uint64, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *EmailLogMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
}

// SetAppID sets the "app_id" field.
func (m *EmailLogMutation) SetAppID(u uint64) {
	m.app = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *EmailLogMutation) AppID() (r uint64, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldAppID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *EmailLogMutation) ResetAppID() {
	m.app = nil
}

// SetEmail sets the "email" field.
func (m *EmailLogMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *EmailLogMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *EmailLogMutation) ResetEmail() {
	m.email = nil
}

// SetScope sets the "scope" field.
func (m *EmailLogMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *EmailLogMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *EmailLogMutation) ResetScope() {
	m.scope = nil
}

// SetTypeID sets the "type_id" field.
func (m *EmailLogMutation) SetTypeID(u uint64) {
	m.type_id = &u
	m.addtype_id = nil
}

// TypeID returns the value of the "type_id" field in the mutation.
func (m *EmailLogMutation) TypeID() (r uint64, exists bool) {
	v := m.type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeID returns the old "type_id" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldTypeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeID: %w", err)
	}
	return oldValue.TypeID, nil
}

// AddTypeID adds u to the "type_id" field.
func (m *EmailLogMutation) AddTypeID(u uint64) {
	if m.addtype_id != nil {
		*m.addtype_id += u
	} else {
		m.addtype_id = &u
	}
}

// AddedTypeID returns the value that was added to the "type_id" field in this mutation.
func (m *EmailLogMutation) AddedTypeID() (r uint64, exists bool) {
	v := m.addtype_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTypeID resets all changes to the "type_id" field.
func (m *EmailLogMutation) ResetTypeID() {
	m.type_id = nil
	m.addtype_id = nil
}

// SetGateway sets the "gateway" field.
func (m *EmailLogMutation) SetGateway(s string) {
	m.gateway = &s
}

// Gateway returns the value of the "gateway" field in the mutation.
func (m *EmailLogMutation) Gateway() (r string, exists bool) {
	v := m.gateway
	if v == nil {
		return
	}
	return *v, true
}

// OldGateway returns the old "gateway" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldGateway(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGateway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGateway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGateway: %w", err)
	}
	return oldValue.Gateway, nil
}

// ResetGateway resets all changes to the "gateway" field.
func (m *EmailLogMutation) ResetGateway() {
	m.gateway = nil
}

// SetIP sets the "ip" field.
func (m *EmailLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *EmailLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *EmailLogMutation) ResetIP() {
	m.ip = nil
}

// SetFromName sets the "from_name" field.
func (m *EmailLogMutation) SetFromName(s string) {
	m.from_name = &s
}

// FromName returns the value of the "from_name" field in the mutation.
func (m *EmailLogMutation) FromName() (r string, exists bool) {
	v := m.from_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFromName returns the old "from_name" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldFromName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromName: %w", err)
	}
	return oldValue.FromName, nil
}

// ResetFromName resets all changes to the "from_name" field.
func (m *EmailLogMutation) ResetFromName() {
	m.from_name = nil
}

// SetFromAddress sets the "from_address" field.
func (m *EmailLogMutation) SetFromAddress(s string) {
	m.from_address = &s
}

// FromAddress returns the value of the "from_address" field in the mutation.
func (m *EmailLogMutation) FromAddress() (r string, exists bool) {
	v := m.from_address
	if v == nil {
		return
	}
	return *v, true
}

// OldFromAddress returns the old "from_address" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldFromAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromAddress: %w", err)
	}
	return oldValue.FromAddress, nil
}

// ResetFromAddress resets all changes to the "from_address" field.
func (m *EmailLogMutation) ResetFromAddress() {
	m.from_address = nil
}

// SetTitle sets the "title" field.
func (m *EmailLogMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *EmailLogMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *EmailLogMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *EmailLogMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *EmailLogMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *EmailLogMutation) ResetContent() {
	m.content = nil
}

// SetData sets the "data" field.
func (m *EmailLogMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *EmailLogMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *EmailLogMutation) ResetData() {
	m.data = nil
}

// SetCheckCount sets the "check_count" field.
func (m *EmailLogMutation) SetCheckCount(u uint8) {
	m.check_count = &u
	m.addcheck_count = nil
}

// CheckCount returns the value of the "check_count" field in the mutation.
func (m *EmailLogMutation) CheckCount() (r uint8, exists bool) {
	v := m.check_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckCount returns the old "check_count" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldCheckCount(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckCount: %w", err)
	}
	return oldValue.CheckCount, nil
}

// AddCheckCount adds u to the "check_count" field.
func (m *EmailLogMutation) AddCheckCount(u uint8) {
	if m.addcheck_count != nil {
		*m.addcheck_count += u
	} else {
		m.addcheck_count = &u
	}
}

// AddedCheckCount returns the value that was added to the "check_count" field in this mutation.
func (m *EmailLogMutation) AddedCheckCount() (r uint8, exists bool) {
	v := m.addcheck_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCheckCount resets all changes to the "check_count" field.
func (m *EmailLogMutation) ResetCheckCount() {
	m.check_count = nil
	m.addcheck_count = nil
}

// SetStatus sets the "status" field.
func (m *EmailLogMutation) SetStatus(u uint) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *EmailLogMutation) Status() (r uint, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldStatus(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *EmailLogMutation) AddStatus(u uint) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *EmailLogMutation) AddedStatus() (r uint, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *EmailLogMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetReturnMsg sets the "return_msg" field.
func (m *EmailLogMutation) SetReturnMsg(s string) {
	m.return_msg = &s
}

// ReturnMsg returns the value of the "return_msg" field in the mutation.
func (m *EmailLogMutation) ReturnMsg() (r string, exists bool) {
	v := m.return_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldReturnMsg returns the old "return_msg" field's value of the EmailLog entity.
// If the EmailLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailLogMutation) OldReturnMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReturnMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReturnMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReturnMsg: %w", err)
	}
	return oldValue.ReturnMsg, nil
}

// ResetReturnMsg resets all changes to the "return_msg" field.
func (m *EmailLogMutation) ResetReturnMsg() {
	m.return_msg = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *EmailLogMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *EmailLogMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *EmailLogMutation) AppIDs() (ids []uint64) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *EmailLogMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// Where appends a list predicates to the EmailLogMutation builder.
func (m *EmailLogMutation) Where(ps ...predicate.EmailLog) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EmailLogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EmailLog).
func (m *EmailLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailLogMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.create_time != nil {
		fields = append(fields, emaillog.FieldCreateTime)
	}
	if m.create_by != nil {
		fields = append(fields, emaillog.FieldCreateBy)
	}
	if m.update_time != nil {
		fields = append(fields, emaillog.FieldUpdateTime)
	}
	if m.update_by != nil {
		fields = append(fields, emaillog.FieldUpdateBy)
	}
	if m.app != nil {
		fields = append(fields, emaillog.FieldAppID)
	}
	if m.email != nil {
		fields = append(fields, emaillog.FieldEmail)
	}
	if m.scope != nil {
		fields = append(fields, emaillog.FieldScope)
	}
	if m.type_id != nil {
		fields = append(fields, emaillog.FieldTypeID)
	}
	if m.gateway != nil {
		fields = append(fields, emaillog.FieldGateway)
	}
	if m.ip != nil {
		fields = append(fields, emaillog.FieldIP)
	}
	if m.from_name != nil {
		fields = append(fields, emaillog.FieldFromName)
	}
	if m.from_address != nil {
		fields = append(fields, emaillog.FieldFromAddress)
	}
	if m.title != nil {
		fields = append(fields, emaillog.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, emaillog.FieldContent)
	}
	if m.data != nil {
		fields = append(fields, emaillog.FieldData)
	}
	if m.check_count != nil {
		fields = append(fields, emaillog.FieldCheckCount)
	}
	if m.status != nil {
		fields = append(fields, emaillog.FieldStatus)
	}
	if m.return_msg != nil {
		fields = append(fields, emaillog.FieldReturnMsg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emaillog.FieldCreateTime:
		return m.CreateTime()
	case emaillog.FieldCreateBy:
		return m.CreateBy()
	case emaillog.FieldUpdateTime:
		return m.UpdateTime()
	case emaillog.FieldUpdateBy:
		return m.UpdateBy()
	case emaillog.FieldAppID:
		return m.AppID()
	case emaillog.FieldEmail:
		return m.Email()
	case emaillog.FieldScope:
		return m.Scope()
	case emaillog.FieldTypeID:
		return m.TypeID()
	case emaillog.FieldGateway:
		return m.Gateway()
	case emaillog.FieldIP:
		return m.IP()
	case emaillog.FieldFromName:
		return m.FromName()
	case emaillog.FieldFromAddress:
		return m.FromAddress()
	case emaillog.FieldTitle:
		return m.Title()
	case emaillog.FieldContent:
		return m.Content()
	case emaillog.FieldData:
		return m.Data()
	case emaillog.FieldCheckCount:
		return m.CheckCount()
	case emaillog.FieldStatus:
		return m.Status()
	case emaillog.FieldReturnMsg:
		return m.ReturnMsg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emaillog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case emaillog.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case emaillog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case emaillog.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case emaillog.FieldAppID:
		return m.OldAppID(ctx)
	case emaillog.FieldEmail:
		return m.OldEmail(ctx)
	case emaillog.FieldScope:
		return m.OldScope(ctx)
	case emaillog.FieldTypeID:
		return m.OldTypeID(ctx)
	case emaillog.FieldGateway:
		return m.OldGateway(ctx)
	case emaillog.FieldIP:
		return m.OldIP(ctx)
	case emaillog.FieldFromName:
		return m.OldFromName(ctx)
	case emaillog.FieldFromAddress:
		return m.OldFromAddress(ctx)
	case emaillog.FieldTitle:
		return m.OldTitle(ctx)
	case emaillog.FieldContent:
		return m.OldContent(ctx)
	case emaillog.FieldData:
		return m.OldData(ctx)
	case emaillog.FieldCheckCount:
		return m.OldCheckCount(ctx)
	case emaillog.FieldStatus:
		return m.OldStatus(ctx)
	case emaillog.FieldReturnMsg:
		return m.OldReturnMsg(ctx)
	}
	return nil, fmt.Errorf("unknown EmailLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emaillog.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case emaillog.FieldCreateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case emaillog.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case emaillog.FieldUpdateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case emaillog.FieldAppID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case emaillog.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case emaillog.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case emaillog.FieldTypeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeID(v)
		return nil
	case emaillog.FieldGateway:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGateway(v)
		return nil
	case emaillog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case emaillog.FieldFromName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromName(v)
		return nil
	case emaillog.FieldFromAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromAddress(v)
		return nil
	case emaillog.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case emaillog.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case emaillog.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case emaillog.FieldCheckCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckCount(v)
		return nil
	case emaillog.FieldStatus:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case emaillog.FieldReturnMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReturnMsg(v)
		return nil
	}
	return fmt.Errorf("unknown EmailLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailLogMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_time != nil {
		fields = append(fields, emaillog.FieldCreateTime)
	}
	if m.addcreate_by != nil {
		fields = append(fields, emaillog.FieldCreateBy)
	}
	if m.addupdate_time != nil {
		fields = append(fields, emaillog.FieldUpdateTime)
	}
	if m.addupdate_by != nil {
		fields = append(fields, emaillog.FieldUpdateBy)
	}
	if m.addtype_id != nil {
		fields = append(fields, emaillog.FieldTypeID)
	}
	if m.addcheck_count != nil {
		fields = append(fields, emaillog.FieldCheckCount)
	}
	if m.addstatus != nil {
		fields = append(fields, emaillog.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case emaillog.FieldCreateTime:
		return m.AddedCreateTime()
	case emaillog.FieldCreateBy:
		return m.AddedCreateBy()
	case emaillog.FieldUpdateTime:
		return m.AddedUpdateTime()
	case emaillog.FieldUpdateBy:
		return m.AddedUpdateBy()
	case emaillog.FieldTypeID:
		return m.AddedTypeID()
	case emaillog.FieldCheckCount:
		return m.AddedCheckCount()
	case emaillog.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case emaillog.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case emaillog.FieldCreateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case emaillog.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	case emaillog.FieldUpdateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case emaillog.FieldTypeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTypeID(v)
		return nil
	case emaillog.FieldCheckCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCheckCount(v)
		return nil
	case emaillog.FieldStatus:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown EmailLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EmailLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailLogMutation) ResetField(name string) error {
	switch name {
	case emaillog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case emaillog.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case emaillog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case emaillog.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case emaillog.FieldAppID:
		m.ResetAppID()
		return nil
	case emaillog.FieldEmail:
		m.ResetEmail()
		return nil
	case emaillog.FieldScope:
		m.ResetScope()
		return nil
	case emaillog.FieldTypeID:
		m.ResetTypeID()
		return nil
	case emaillog.FieldGateway:
		m.ResetGateway()
		return nil
	case emaillog.FieldIP:
		m.ResetIP()
		return nil
	case emaillog.FieldFromName:
		m.ResetFromName()
		return nil
	case emaillog.FieldFromAddress:
		m.ResetFromAddress()
		return nil
	case emaillog.FieldTitle:
		m.ResetTitle()
		return nil
	case emaillog.FieldContent:
		m.ResetContent()
		return nil
	case emaillog.FieldData:
		m.ResetData()
		return nil
	case emaillog.FieldCheckCount:
		m.ResetCheckCount()
		return nil
	case emaillog.FieldStatus:
		m.ResetStatus()
		return nil
	case emaillog.FieldReturnMsg:
		m.ResetReturnMsg()
		return nil
	}
	return fmt.Errorf("unknown EmailLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.app != nil {
		edges = append(edges, emaillog.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emaillog.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailLogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapp {
		edges = append(edges, emaillog.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailLogMutation) EdgeCleared(name string) bool {
	switch name {
	case emaillog.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailLogMutation) ClearEdge(name string) error {
	switch name {
	case emaillog.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown EmailLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailLogMutation) ResetEdge(name string) error {
	switch name {
	case emaillog.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown EmailLog edge %s", name)
}

// SmsLogMutation represents an operation that mutates the SmsLog nodes in the graph.
type SmsLogMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	create_time    *int64
	addcreate_time *int64
	create_by      *uint64
	addcreate_by   *uint64
	update_time    *int64
	addupdate_time *int64
	update_by      *uint64
	addupdate_by   *uint64
	dial_code      *string
	mobile         *string
	scope          *string
	type_id        *uint64
	addtype_id     *uint64
	gateway        *string
	ip             *string
	template_id    *string
	template_text  *string
	content        *string
	check_count    *uint8
	addcheck_count *uint8
	status         *uint
	addstatus      *uint
	return_msg     *string
	clearedFields  map[string]struct{}
	app            *uint64
	clearedapp     bool
	done           bool
	oldValue       func(context.Context) (*SmsLog, error)
	predicates     []predicate.SmsLog
}

var _ ent.Mutation = (*SmsLogMutation)(nil)

// smslogOption allows management of the mutation configuration using functional options.
type smslogOption func(*SmsLogMutation)

// newSmsLogMutation creates new mutation for the SmsLog entity.
func newSmsLogMutation(c config, op Op, opts ...smslogOption) *SmsLogMutation {
	m := &SmsLogMutation{
		config:        c,
		op:            op,
		typ:           TypeSmsLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSmsLogID sets the ID field of the mutation.
func withSmsLogID(id uint64) smslogOption {
	return func(m *SmsLogMutation) {
		var (
			err   error
			once  sync.Once
			value *SmsLog
		)
		m.oldValue = func(ctx context.Context) (*SmsLog, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SmsLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSmsLog sets the old SmsLog of the mutation.
func withSmsLog(node *SmsLog) smslogOption {
	return func(m *SmsLogMutation) {
		m.oldValue = func(context.Context) (*SmsLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SmsLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SmsLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SmsLog entities.
func (m *SmsLogMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SmsLogMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SmsLogMutation) SetCreateTime(i int64) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SmsLogMutation) CreateTime() (r int64, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldCreateTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *SmsLogMutation) AddCreateTime(i int64) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *SmsLogMutation) AddedCreateTime() (r int64, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SmsLogMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
}

// SetCreateBy sets the "create_by" field.
func (m *SmsLogMutation) SetCreateBy(u uint64) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *SmsLogMutation) CreateBy() (r uint64, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldCreateBy(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *SmsLogMutation) AddCreateBy(u uint64) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *SmsLogMutation) AddedCreateBy() (r uint64, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *SmsLogMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SmsLogMutation) SetUpdateTime(i int64) {
	m.update_time = &i
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SmsLogMutation) UpdateTime() (r int64, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldUpdateTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds i to the "update_time" field.
func (m *SmsLogMutation) AddUpdateTime(i int64) {
	if m.addupdate_time != nil {
		*m.addupdate_time += i
	} else {
		m.addupdate_time = &i
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *SmsLogMutation) AddedUpdateTime() (r int64, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SmsLogMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
}

// SetUpdateBy sets the "update_by" field.
func (m *SmsLogMutation) SetUpdateBy(u uint64) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *SmsLogMutation) UpdateBy() (r uint64, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldUpdateBy(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *SmsLogMutation) AddUpdateBy(u uint64) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *SmsLogMutation) AddedUpdateBy() (r uint64, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *SmsLogMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
}

// SetAppID sets the "app_id" field.
func (m *SmsLogMutation) SetAppID(u uint64) {
	m.app = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *SmsLogMutation) AppID() (r uint64, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldAppID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *SmsLogMutation) ResetAppID() {
	m.app = nil
}

// SetDialCode sets the "dial_code" field.
func (m *SmsLogMutation) SetDialCode(s string) {
	m.dial_code = &s
}

// DialCode returns the value of the "dial_code" field in the mutation.
func (m *SmsLogMutation) DialCode() (r string, exists bool) {
	v := m.dial_code
	if v == nil {
		return
	}
	return *v, true
}

// OldDialCode returns the old "dial_code" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldDialCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDialCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDialCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDialCode: %w", err)
	}
	return oldValue.DialCode, nil
}

// ResetDialCode resets all changes to the "dial_code" field.
func (m *SmsLogMutation) ResetDialCode() {
	m.dial_code = nil
}

// SetMobile sets the "mobile" field.
func (m *SmsLogMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *SmsLogMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ResetMobile resets all changes to the "mobile" field.
func (m *SmsLogMutation) ResetMobile() {
	m.mobile = nil
}

// SetScope sets the "scope" field.
func (m *SmsLogMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *SmsLogMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *SmsLogMutation) ResetScope() {
	m.scope = nil
}

// SetTypeID sets the "type_id" field.
func (m *SmsLogMutation) SetTypeID(u uint64) {
	m.type_id = &u
	m.addtype_id = nil
}

// TypeID returns the value of the "type_id" field in the mutation.
func (m *SmsLogMutation) TypeID() (r uint64, exists bool) {
	v := m.type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeID returns the old "type_id" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldTypeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeID: %w", err)
	}
	return oldValue.TypeID, nil
}

// AddTypeID adds u to the "type_id" field.
func (m *SmsLogMutation) AddTypeID(u uint64) {
	if m.addtype_id != nil {
		*m.addtype_id += u
	} else {
		m.addtype_id = &u
	}
}

// AddedTypeID returns the value that was added to the "type_id" field in this mutation.
func (m *SmsLogMutation) AddedTypeID() (r uint64, exists bool) {
	v := m.addtype_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTypeID resets all changes to the "type_id" field.
func (m *SmsLogMutation) ResetTypeID() {
	m.type_id = nil
	m.addtype_id = nil
}

// SetGateway sets the "gateway" field.
func (m *SmsLogMutation) SetGateway(s string) {
	m.gateway = &s
}

// Gateway returns the value of the "gateway" field in the mutation.
func (m *SmsLogMutation) Gateway() (r string, exists bool) {
	v := m.gateway
	if v == nil {
		return
	}
	return *v, true
}

// OldGateway returns the old "gateway" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldGateway(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGateway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGateway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGateway: %w", err)
	}
	return oldValue.Gateway, nil
}

// ResetGateway resets all changes to the "gateway" field.
func (m *SmsLogMutation) ResetGateway() {
	m.gateway = nil
}

// SetIP sets the "ip" field.
func (m *SmsLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *SmsLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *SmsLogMutation) ResetIP() {
	m.ip = nil
}

// SetTemplateID sets the "template_id" field.
func (m *SmsLogMutation) SetTemplateID(s string) {
	m.template_id = &s
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *SmsLogMutation) TemplateID() (r string, exists bool) {
	v := m.template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *SmsLogMutation) ResetTemplateID() {
	m.template_id = nil
}

// SetTemplateText sets the "template_text" field.
func (m *SmsLogMutation) SetTemplateText(s string) {
	m.template_text = &s
}

// TemplateText returns the value of the "template_text" field in the mutation.
func (m *SmsLogMutation) TemplateText() (r string, exists bool) {
	v := m.template_text
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateText returns the old "template_text" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldTemplateText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTemplateText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTemplateText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateText: %w", err)
	}
	return oldValue.TemplateText, nil
}

// ResetTemplateText resets all changes to the "template_text" field.
func (m *SmsLogMutation) ResetTemplateText() {
	m.template_text = nil
}

// SetContent sets the "content" field.
func (m *SmsLogMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *SmsLogMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *SmsLogMutation) ResetContent() {
	m.content = nil
}

// SetCheckCount sets the "check_count" field.
func (m *SmsLogMutation) SetCheckCount(u uint8) {
	m.check_count = &u
	m.addcheck_count = nil
}

// CheckCount returns the value of the "check_count" field in the mutation.
func (m *SmsLogMutation) CheckCount() (r uint8, exists bool) {
	v := m.check_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckCount returns the old "check_count" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldCheckCount(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckCount: %w", err)
	}
	return oldValue.CheckCount, nil
}

// AddCheckCount adds u to the "check_count" field.
func (m *SmsLogMutation) AddCheckCount(u uint8) {
	if m.addcheck_count != nil {
		*m.addcheck_count += u
	} else {
		m.addcheck_count = &u
	}
}

// AddedCheckCount returns the value that was added to the "check_count" field in this mutation.
func (m *SmsLogMutation) AddedCheckCount() (r uint8, exists bool) {
	v := m.addcheck_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCheckCount resets all changes to the "check_count" field.
func (m *SmsLogMutation) ResetCheckCount() {
	m.check_count = nil
	m.addcheck_count = nil
}

// SetStatus sets the "status" field.
func (m *SmsLogMutation) SetStatus(u uint) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SmsLogMutation) Status() (r uint, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldStatus(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *SmsLogMutation) AddStatus(u uint) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SmsLogMutation) AddedStatus() (r uint, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *SmsLogMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetReturnMsg sets the "return_msg" field.
func (m *SmsLogMutation) SetReturnMsg(s string) {
	m.return_msg = &s
}

// ReturnMsg returns the value of the "return_msg" field in the mutation.
func (m *SmsLogMutation) ReturnMsg() (r string, exists bool) {
	v := m.return_msg
	if v == nil {
		return
	}
	return *v, true
}

// OldReturnMsg returns the old "return_msg" field's value of the SmsLog entity.
// If the SmsLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SmsLogMutation) OldReturnMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReturnMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReturnMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReturnMsg: %w", err)
	}
	return oldValue.ReturnMsg, nil
}

// ResetReturnMsg resets all changes to the "return_msg" field.
func (m *SmsLogMutation) ResetReturnMsg() {
	m.return_msg = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *SmsLogMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *SmsLogMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *SmsLogMutation) AppIDs() (ids []uint64) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *SmsLogMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// Where appends a list predicates to the SmsLogMutation builder.
func (m *SmsLogMutation) Where(ps ...predicate.SmsLog) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SmsLogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SmsLog).
func (m *SmsLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SmsLogMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.create_time != nil {
		fields = append(fields, smslog.FieldCreateTime)
	}
	if m.create_by != nil {
		fields = append(fields, smslog.FieldCreateBy)
	}
	if m.update_time != nil {
		fields = append(fields, smslog.FieldUpdateTime)
	}
	if m.update_by != nil {
		fields = append(fields, smslog.FieldUpdateBy)
	}
	if m.app != nil {
		fields = append(fields, smslog.FieldAppID)
	}
	if m.dial_code != nil {
		fields = append(fields, smslog.FieldDialCode)
	}
	if m.mobile != nil {
		fields = append(fields, smslog.FieldMobile)
	}
	if m.scope != nil {
		fields = append(fields, smslog.FieldScope)
	}
	if m.type_id != nil {
		fields = append(fields, smslog.FieldTypeID)
	}
	if m.gateway != nil {
		fields = append(fields, smslog.FieldGateway)
	}
	if m.ip != nil {
		fields = append(fields, smslog.FieldIP)
	}
	if m.template_id != nil {
		fields = append(fields, smslog.FieldTemplateID)
	}
	if m.template_text != nil {
		fields = append(fields, smslog.FieldTemplateText)
	}
	if m.content != nil {
		fields = append(fields, smslog.FieldContent)
	}
	if m.check_count != nil {
		fields = append(fields, smslog.FieldCheckCount)
	}
	if m.status != nil {
		fields = append(fields, smslog.FieldStatus)
	}
	if m.return_msg != nil {
		fields = append(fields, smslog.FieldReturnMsg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SmsLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case smslog.FieldCreateTime:
		return m.CreateTime()
	case smslog.FieldCreateBy:
		return m.CreateBy()
	case smslog.FieldUpdateTime:
		return m.UpdateTime()
	case smslog.FieldUpdateBy:
		return m.UpdateBy()
	case smslog.FieldAppID:
		return m.AppID()
	case smslog.FieldDialCode:
		return m.DialCode()
	case smslog.FieldMobile:
		return m.Mobile()
	case smslog.FieldScope:
		return m.Scope()
	case smslog.FieldTypeID:
		return m.TypeID()
	case smslog.FieldGateway:
		return m.Gateway()
	case smslog.FieldIP:
		return m.IP()
	case smslog.FieldTemplateID:
		return m.TemplateID()
	case smslog.FieldTemplateText:
		return m.TemplateText()
	case smslog.FieldContent:
		return m.Content()
	case smslog.FieldCheckCount:
		return m.CheckCount()
	case smslog.FieldStatus:
		return m.Status()
	case smslog.FieldReturnMsg:
		return m.ReturnMsg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SmsLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case smslog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case smslog.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case smslog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case smslog.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case smslog.FieldAppID:
		return m.OldAppID(ctx)
	case smslog.FieldDialCode:
		return m.OldDialCode(ctx)
	case smslog.FieldMobile:
		return m.OldMobile(ctx)
	case smslog.FieldScope:
		return m.OldScope(ctx)
	case smslog.FieldTypeID:
		return m.OldTypeID(ctx)
	case smslog.FieldGateway:
		return m.OldGateway(ctx)
	case smslog.FieldIP:
		return m.OldIP(ctx)
	case smslog.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case smslog.FieldTemplateText:
		return m.OldTemplateText(ctx)
	case smslog.FieldContent:
		return m.OldContent(ctx)
	case smslog.FieldCheckCount:
		return m.OldCheckCount(ctx)
	case smslog.FieldStatus:
		return m.OldStatus(ctx)
	case smslog.FieldReturnMsg:
		return m.OldReturnMsg(ctx)
	}
	return nil, fmt.Errorf("unknown SmsLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SmsLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case smslog.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case smslog.FieldCreateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case smslog.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case smslog.FieldUpdateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case smslog.FieldAppID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case smslog.FieldDialCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDialCode(v)
		return nil
	case smslog.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case smslog.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	case smslog.FieldTypeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeID(v)
		return nil
	case smslog.FieldGateway:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGateway(v)
		return nil
	case smslog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case smslog.FieldTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case smslog.FieldTemplateText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateText(v)
		return nil
	case smslog.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case smslog.FieldCheckCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckCount(v)
		return nil
	case smslog.FieldStatus:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case smslog.FieldReturnMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReturnMsg(v)
		return nil
	}
	return fmt.Errorf("unknown SmsLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SmsLogMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_time != nil {
		fields = append(fields, smslog.FieldCreateTime)
	}
	if m.addcreate_by != nil {
		fields = append(fields, smslog.FieldCreateBy)
	}
	if m.addupdate_time != nil {
		fields = append(fields, smslog.FieldUpdateTime)
	}
	if m.addupdate_by != nil {
		fields = append(fields, smslog.FieldUpdateBy)
	}
	if m.addtype_id != nil {
		fields = append(fields, smslog.FieldTypeID)
	}
	if m.addcheck_count != nil {
		fields = append(fields, smslog.FieldCheckCount)
	}
	if m.addstatus != nil {
		fields = append(fields, smslog.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SmsLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case smslog.FieldCreateTime:
		return m.AddedCreateTime()
	case smslog.FieldCreateBy:
		return m.AddedCreateBy()
	case smslog.FieldUpdateTime:
		return m.AddedUpdateTime()
	case smslog.FieldUpdateBy:
		return m.AddedUpdateBy()
	case smslog.FieldTypeID:
		return m.AddedTypeID()
	case smslog.FieldCheckCount:
		return m.AddedCheckCount()
	case smslog.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SmsLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case smslog.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case smslog.FieldCreateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case smslog.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	case smslog.FieldUpdateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case smslog.FieldTypeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTypeID(v)
		return nil
	case smslog.FieldCheckCount:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCheckCount(v)
		return nil
	case smslog.FieldStatus:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown SmsLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SmsLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SmsLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SmsLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SmsLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SmsLogMutation) ResetField(name string) error {
	switch name {
	case smslog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case smslog.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case smslog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case smslog.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case smslog.FieldAppID:
		m.ResetAppID()
		return nil
	case smslog.FieldDialCode:
		m.ResetDialCode()
		return nil
	case smslog.FieldMobile:
		m.ResetMobile()
		return nil
	case smslog.FieldScope:
		m.ResetScope()
		return nil
	case smslog.FieldTypeID:
		m.ResetTypeID()
		return nil
	case smslog.FieldGateway:
		m.ResetGateway()
		return nil
	case smslog.FieldIP:
		m.ResetIP()
		return nil
	case smslog.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case smslog.FieldTemplateText:
		m.ResetTemplateText()
		return nil
	case smslog.FieldContent:
		m.ResetContent()
		return nil
	case smslog.FieldCheckCount:
		m.ResetCheckCount()
		return nil
	case smslog.FieldStatus:
		m.ResetStatus()
		return nil
	case smslog.FieldReturnMsg:
		m.ResetReturnMsg()
		return nil
	}
	return fmt.Errorf("unknown SmsLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SmsLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.app != nil {
		edges = append(edges, smslog.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SmsLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case smslog.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SmsLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SmsLogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SmsLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapp {
		edges = append(edges, smslog.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SmsLogMutation) EdgeCleared(name string) bool {
	switch name {
	case smslog.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SmsLogMutation) ClearEdge(name string) error {
	switch name {
	case smslog.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown SmsLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SmsLogMutation) ResetEdge(name string) error {
	switch name {
	case smslog.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown SmsLog edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	delete_time        *int64
	adddelete_time     *int64
	create_time        *int64
	addcreate_time     *int64
	create_by          *uint64
	addcreate_by       *uint64
	update_time        *int64
	addupdate_time     *int64
	update_by          *uint64
	addupdate_by       *uint64
	uuid               *uuid.UUID
	username           *string
	nickname           *string
	password           *string
	dial_code          *string
	mobile             *string
	mobile_hash        *string
	email              *string
	email_hash         *string
	avatar             *string
	name               *string
	sex                *uint
	addsex             *uint
	birthday           *uint64
	addbirthday        *uint64
	age                *uint
	addage             *uint
	last_login_ip      *string
	last_login_time    *uint64
	addlast_login_time *uint64
	status             *uint
	addstatus          *uint
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uint64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDeleteTime sets the "delete_time" field.
func (m *UserMutation) SetDeleteTime(i int64) {
	m.delete_time = &i
	m.adddelete_time = nil
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *UserMutation) DeleteTime() (r int64, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeleteTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// AddDeleteTime adds i to the "delete_time" field.
func (m *UserMutation) AddDeleteTime(i int64) {
	if m.adddelete_time != nil {
		*m.adddelete_time += i
	} else {
		m.adddelete_time = &i
	}
}

// AddedDeleteTime returns the value that was added to the "delete_time" field in this mutation.
func (m *UserMutation) AddedDeleteTime() (r int64, exists bool) {
	v := m.adddelete_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *UserMutation) ResetDeleteTime() {
	m.delete_time = nil
	m.adddelete_time = nil
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(i int64) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r int64, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *UserMutation) AddCreateTime(i int64) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *UserMutation) AddedCreateTime() (r int64, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
}

// SetCreateBy sets the "create_by" field.
func (m *UserMutation) SetCreateBy(u uint64) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *UserMutation) CreateBy() (r uint64, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateBy(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *UserMutation) AddCreateBy(u uint64) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *UserMutation) AddedCreateBy() (r uint64, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *UserMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(i int64) {
	m.update_time = &i
	m.addupdate_time = nil
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r int64, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// AddUpdateTime adds i to the "update_time" field.
func (m *UserMutation) AddUpdateTime(i int64) {
	if m.addupdate_time != nil {
		*m.addupdate_time += i
	} else {
		m.addupdate_time = &i
	}
}

// AddedUpdateTime returns the value that was added to the "update_time" field in this mutation.
func (m *UserMutation) AddedUpdateTime() (r int64, exists bool) {
	v := m.addupdate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
	m.addupdate_time = nil
}

// SetUpdateBy sets the "update_by" field.
func (m *UserMutation) SetUpdateBy(u uint64) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *UserMutation) UpdateBy() (r uint64, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateBy(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *UserMutation) AddUpdateBy(u uint64) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *UserMutation) AddedUpdateBy() (r uint64, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *UserMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
}

// SetUUID sets the "uuid" field.
func (m *UserMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *UserMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *UserMutation) ResetUUID() {
	m.uuid = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetDialCode sets the "dial_code" field.
func (m *UserMutation) SetDialCode(s string) {
	m.dial_code = &s
}

// DialCode returns the value of the "dial_code" field in the mutation.
func (m *UserMutation) DialCode() (r string, exists bool) {
	v := m.dial_code
	if v == nil {
		return
	}
	return *v, true
}

// OldDialCode returns the old "dial_code" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDialCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDialCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDialCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDialCode: %w", err)
	}
	return oldValue.DialCode, nil
}

// ResetDialCode resets all changes to the "dial_code" field.
func (m *UserMutation) ResetDialCode() {
	m.dial_code = nil
}

// SetMobile sets the "mobile" field.
func (m *UserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *UserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ResetMobile resets all changes to the "mobile" field.
func (m *UserMutation) ResetMobile() {
	m.mobile = nil
}

// SetMobileHash sets the "mobile_hash" field.
func (m *UserMutation) SetMobileHash(s string) {
	m.mobile_hash = &s
}

// MobileHash returns the value of the "mobile_hash" field in the mutation.
func (m *UserMutation) MobileHash() (r string, exists bool) {
	v := m.mobile_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileHash returns the old "mobile_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobileHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMobileHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMobileHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileHash: %w", err)
	}
	return oldValue.MobileHash, nil
}

// ResetMobileHash resets all changes to the "mobile_hash" field.
func (m *UserMutation) ResetMobileHash() {
	m.mobile_hash = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetEmailHash sets the "email_hash" field.
func (m *UserMutation) SetEmailHash(s string) {
	m.email_hash = &s
}

// EmailHash returns the value of the "email_hash" field in the mutation.
func (m *UserMutation) EmailHash() (r string, exists bool) {
	v := m.email_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailHash returns the old "email_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmailHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmailHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailHash: %w", err)
	}
	return oldValue.EmailHash, nil
}

// ResetEmailHash resets all changes to the "email_hash" field.
func (m *UserMutation) ResetEmailHash() {
	m.email_hash = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetSex sets the "sex" field.
func (m *UserMutation) SetSex(u uint) {
	m.sex = &u
	m.addsex = nil
}

// Sex returns the value of the "sex" field in the mutation.
func (m *UserMutation) Sex() (r uint, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSex(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// AddSex adds u to the "sex" field.
func (m *UserMutation) AddSex(u uint) {
	if m.addsex != nil {
		*m.addsex += u
	} else {
		m.addsex = &u
	}
}

// AddedSex returns the value that was added to the "sex" field in this mutation.
func (m *UserMutation) AddedSex() (r uint, exists bool) {
	v := m.addsex
	if v == nil {
		return
	}
	return *v, true
}

// ResetSex resets all changes to the "sex" field.
func (m *UserMutation) ResetSex() {
	m.sex = nil
	m.addsex = nil
}

// SetBirthday sets the "birthday" field.
func (m *UserMutation) SetBirthday(u uint64) {
	m.birthday = &u
	m.addbirthday = nil
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *UserMutation) Birthday() (r uint64, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthday(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// AddBirthday adds u to the "birthday" field.
func (m *UserMutation) AddBirthday(u uint64) {
	if m.addbirthday != nil {
		*m.addbirthday += u
	} else {
		m.addbirthday = &u
	}
}

// AddedBirthday returns the value that was added to the "birthday" field in this mutation.
func (m *UserMutation) AddedBirthday() (r uint64, exists bool) {
	v := m.addbirthday
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *UserMutation) ResetBirthday() {
	m.birthday = nil
	m.addbirthday = nil
}

// SetAge sets the "age" field.
func (m *UserMutation) SetAge(u uint) {
	m.age = &u
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *UserMutation) Age() (r uint, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAge(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds u to the "age" field.
func (m *UserMutation) AddAge(u uint) {
	if m.addage != nil {
		*m.addage += u
	} else {
		m.addage = &u
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *UserMutation) AddedAge() (r uint, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *UserMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetLastLoginIP sets the "last_login_ip" field.
func (m *UserMutation) SetLastLoginIP(s string) {
	m.last_login_ip = &s
}

// LastLoginIP returns the value of the "last_login_ip" field in the mutation.
func (m *UserMutation) LastLoginIP() (r string, exists bool) {
	v := m.last_login_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginIP returns the old "last_login_ip" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastLoginIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastLoginIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginIP: %w", err)
	}
	return oldValue.LastLoginIP, nil
}

// ResetLastLoginIP resets all changes to the "last_login_ip" field.
func (m *UserMutation) ResetLastLoginIP() {
	m.last_login_ip = nil
}

// SetLastLoginTime sets the "last_login_time" field.
func (m *UserMutation) SetLastLoginTime(u uint64) {
	m.last_login_time = &u
	m.addlast_login_time = nil
}

// LastLoginTime returns the value of the "last_login_time" field in the mutation.
func (m *UserMutation) LastLoginTime() (r uint64, exists bool) {
	v := m.last_login_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginTime returns the old "last_login_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginTime(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastLoginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastLoginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginTime: %w", err)
	}
	return oldValue.LastLoginTime, nil
}

// AddLastLoginTime adds u to the "last_login_time" field.
func (m *UserMutation) AddLastLoginTime(u uint64) {
	if m.addlast_login_time != nil {
		*m.addlast_login_time += u
	} else {
		m.addlast_login_time = &u
	}
}

// AddedLastLoginTime returns the value that was added to the "last_login_time" field in this mutation.
func (m *UserMutation) AddedLastLoginTime() (r uint64, exists bool) {
	v := m.addlast_login_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastLoginTime resets all changes to the "last_login_time" field.
func (m *UserMutation) ResetLastLoginTime() {
	m.last_login_time = nil
	m.addlast_login_time = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u uint) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r uint, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *UserMutation) AddStatus(u uint) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r uint, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.delete_time != nil {
		fields = append(fields, user.FieldDeleteTime)
	}
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.create_by != nil {
		fields = append(fields, user.FieldCreateBy)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.update_by != nil {
		fields = append(fields, user.FieldUpdateBy)
	}
	if m.uuid != nil {
		fields = append(fields, user.FieldUUID)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.dial_code != nil {
		fields = append(fields, user.FieldDialCode)
	}
	if m.mobile != nil {
		fields = append(fields, user.FieldMobile)
	}
	if m.mobile_hash != nil {
		fields = append(fields, user.FieldMobileHash)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.email_hash != nil {
		fields = append(fields, user.FieldEmailHash)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.sex != nil {
		fields = append(fields, user.FieldSex)
	}
	if m.birthday != nil {
		fields = append(fields, user.FieldBirthday)
	}
	if m.age != nil {
		fields = append(fields, user.FieldAge)
	}
	if m.last_login_ip != nil {
		fields = append(fields, user.FieldLastLoginIP)
	}
	if m.last_login_time != nil {
		fields = append(fields, user.FieldLastLoginTime)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDeleteTime:
		return m.DeleteTime()
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldCreateBy:
		return m.CreateBy()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldUpdateBy:
		return m.UpdateBy()
	case user.FieldUUID:
		return m.UUID()
	case user.FieldUsername:
		return m.Username()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldPassword:
		return m.Password()
	case user.FieldDialCode:
		return m.DialCode()
	case user.FieldMobile:
		return m.Mobile()
	case user.FieldMobileHash:
		return m.MobileHash()
	case user.FieldEmail:
		return m.Email()
	case user.FieldEmailHash:
		return m.EmailHash()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldName:
		return m.Name()
	case user.FieldSex:
		return m.Sex()
	case user.FieldBirthday:
		return m.Birthday()
	case user.FieldAge:
		return m.Age()
	case user.FieldLastLoginIP:
		return m.LastLoginIP()
	case user.FieldLastLoginTime:
		return m.LastLoginTime()
	case user.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case user.FieldUUID:
		return m.OldUUID(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldDialCode:
		return m.OldDialCode(ctx)
	case user.FieldMobile:
		return m.OldMobile(ctx)
	case user.FieldMobileHash:
		return m.OldMobileHash(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldEmailHash:
		return m.OldEmailHash(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldSex:
		return m.OldSex(ctx)
	case user.FieldBirthday:
		return m.OldBirthday(ctx)
	case user.FieldAge:
		return m.OldAge(ctx)
	case user.FieldLastLoginIP:
		return m.OldLastLoginIP(ctx)
	case user.FieldLastLoginTime:
		return m.OldLastLoginTime(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case user.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldCreateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldUpdateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case user.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldDialCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDialCode(v)
		return nil
	case user.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case user.FieldMobileHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileHash(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldEmailHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailHash(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldSex:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case user.FieldBirthday:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case user.FieldAge:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case user.FieldLastLoginIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginIP(v)
		return nil
	case user.FieldLastLoginTime:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginTime(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.adddelete_time != nil {
		fields = append(fields, user.FieldDeleteTime)
	}
	if m.addcreate_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.addcreate_by != nil {
		fields = append(fields, user.FieldCreateBy)
	}
	if m.addupdate_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.addupdate_by != nil {
		fields = append(fields, user.FieldUpdateBy)
	}
	if m.addsex != nil {
		fields = append(fields, user.FieldSex)
	}
	if m.addbirthday != nil {
		fields = append(fields, user.FieldBirthday)
	}
	if m.addage != nil {
		fields = append(fields, user.FieldAge)
	}
	if m.addlast_login_time != nil {
		fields = append(fields, user.FieldLastLoginTime)
	}
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDeleteTime:
		return m.AddedDeleteTime()
	case user.FieldCreateTime:
		return m.AddedCreateTime()
	case user.FieldCreateBy:
		return m.AddedCreateBy()
	case user.FieldUpdateTime:
		return m.AddedUpdateTime()
	case user.FieldUpdateBy:
		return m.AddedUpdateBy()
	case user.FieldSex:
		return m.AddedSex()
	case user.FieldBirthday:
		return m.AddedBirthday()
	case user.FieldAge:
		return m.AddedAge()
	case user.FieldLastLoginTime:
		return m.AddedLastLoginTime()
	case user.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldDeleteTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteTime(v)
		return nil
	case user.FieldCreateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case user.FieldCreateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateTime(v)
		return nil
	case user.FieldUpdateBy:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case user.FieldSex:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSex(v)
		return nil
	case user.FieldBirthday:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthday(v)
		return nil
	case user.FieldAge:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case user.FieldLastLoginTime:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastLoginTime(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case user.FieldUUID:
		m.ResetUUID()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldDialCode:
		m.ResetDialCode()
		return nil
	case user.FieldMobile:
		m.ResetMobile()
		return nil
	case user.FieldMobileHash:
		m.ResetMobileHash()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldEmailHash:
		m.ResetEmailHash()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldSex:
		m.ResetSex()
		return nil
	case user.FieldBirthday:
		m.ResetBirthday()
		return nil
	case user.FieldAge:
		m.ResetAge()
		return nil
	case user.FieldLastLoginIP:
		m.ResetLastLoginIP()
		return nil
	case user.FieldLastLoginTime:
		m.ResetLastLoginTime()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
