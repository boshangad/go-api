// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/boshangad/v1/ent/migrate"

	"github.com/boshangad/v1/ent/app"
	"github.com/boshangad/v1/ent/appoption"
	"github.com/boshangad/v1/ent/appuser"
	"github.com/boshangad/v1/ent/appuserloginlog"
	"github.com/boshangad/v1/ent/appusertoken"
	"github.com/boshangad/v1/ent/authassgiment"
	"github.com/boshangad/v1/ent/authitem"
	"github.com/boshangad/v1/ent/authitemchild"
	"github.com/boshangad/v1/ent/authrole"
	"github.com/boshangad/v1/ent/authrule"
	"github.com/boshangad/v1/ent/emaillog"
	"github.com/boshangad/v1/ent/smslog"
	"github.com/boshangad/v1/ent/user"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// App is the client for interacting with the App builders.
	App *AppClient
	// AppOption is the client for interacting with the AppOption builders.
	AppOption *AppOptionClient
	// AppUser is the client for interacting with the AppUser builders.
	AppUser *AppUserClient
	// AppUserLoginLog is the client for interacting with the AppUserLoginLog builders.
	AppUserLoginLog *AppUserLoginLogClient
	// AppUserToken is the client for interacting with the AppUserToken builders.
	AppUserToken *AppUserTokenClient
	// AuthAssgiment is the client for interacting with the AuthAssgiment builders.
	AuthAssgiment *AuthAssgimentClient
	// AuthItem is the client for interacting with the AuthItem builders.
	AuthItem *AuthItemClient
	// AuthItemChild is the client for interacting with the AuthItemChild builders.
	AuthItemChild *AuthItemChildClient
	// AuthRole is the client for interacting with the AuthRole builders.
	AuthRole *AuthRoleClient
	// AuthRule is the client for interacting with the AuthRule builders.
	AuthRule *AuthRuleClient
	// EmailLog is the client for interacting with the EmailLog builders.
	EmailLog *EmailLogClient
	// SmsLog is the client for interacting with the SmsLog builders.
	SmsLog *SmsLogClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.App = NewAppClient(c.config)
	c.AppOption = NewAppOptionClient(c.config)
	c.AppUser = NewAppUserClient(c.config)
	c.AppUserLoginLog = NewAppUserLoginLogClient(c.config)
	c.AppUserToken = NewAppUserTokenClient(c.config)
	c.AuthAssgiment = NewAuthAssgimentClient(c.config)
	c.AuthItem = NewAuthItemClient(c.config)
	c.AuthItemChild = NewAuthItemChildClient(c.config)
	c.AuthRole = NewAuthRoleClient(c.config)
	c.AuthRule = NewAuthRuleClient(c.config)
	c.EmailLog = NewEmailLogClient(c.config)
	c.SmsLog = NewSmsLogClient(c.config)
	c.User = NewUserClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		App:             NewAppClient(cfg),
		AppOption:       NewAppOptionClient(cfg),
		AppUser:         NewAppUserClient(cfg),
		AppUserLoginLog: NewAppUserLoginLogClient(cfg),
		AppUserToken:    NewAppUserTokenClient(cfg),
		AuthAssgiment:   NewAuthAssgimentClient(cfg),
		AuthItem:        NewAuthItemClient(cfg),
		AuthItemChild:   NewAuthItemChildClient(cfg),
		AuthRole:        NewAuthRoleClient(cfg),
		AuthRule:        NewAuthRuleClient(cfg),
		EmailLog:        NewEmailLogClient(cfg),
		SmsLog:          NewSmsLogClient(cfg),
		User:            NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		config:          cfg,
		App:             NewAppClient(cfg),
		AppOption:       NewAppOptionClient(cfg),
		AppUser:         NewAppUserClient(cfg),
		AppUserLoginLog: NewAppUserLoginLogClient(cfg),
		AppUserToken:    NewAppUserTokenClient(cfg),
		AuthAssgiment:   NewAuthAssgimentClient(cfg),
		AuthItem:        NewAuthItemClient(cfg),
		AuthItemChild:   NewAuthItemChildClient(cfg),
		AuthRole:        NewAuthRoleClient(cfg),
		AuthRule:        NewAuthRuleClient(cfg),
		EmailLog:        NewEmailLogClient(cfg),
		SmsLog:          NewSmsLogClient(cfg),
		User:            NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		App.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.App.Use(hooks...)
	c.AppOption.Use(hooks...)
	c.AppUser.Use(hooks...)
	c.AppUserLoginLog.Use(hooks...)
	c.AppUserToken.Use(hooks...)
	c.AuthAssgiment.Use(hooks...)
	c.AuthItem.Use(hooks...)
	c.AuthItemChild.Use(hooks...)
	c.AuthRole.Use(hooks...)
	c.AuthRule.Use(hooks...)
	c.EmailLog.Use(hooks...)
	c.SmsLog.Use(hooks...)
	c.User.Use(hooks...)
}

// AppClient is a client for the App schema.
type AppClient struct {
	config
}

// NewAppClient returns a client for the App from the given config.
func NewAppClient(c config) *AppClient {
	return &AppClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `app.Hooks(f(g(h())))`.
func (c *AppClient) Use(hooks ...Hook) {
	c.hooks.App = append(c.hooks.App, hooks...)
}

// Create returns a create builder for App.
func (c *AppClient) Create() *AppCreate {
	mutation := newAppMutation(c.config, OpCreate)
	return &AppCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of App entities.
func (c *AppClient) CreateBulk(builders ...*AppCreate) *AppCreateBulk {
	return &AppCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for App.
func (c *AppClient) Update() *AppUpdate {
	mutation := newAppMutation(c.config, OpUpdate)
	return &AppUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppClient) UpdateOne(a *App) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withApp(a))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppClient) UpdateOneID(id uint64) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withAppID(id))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for App.
func (c *AppClient) Delete() *AppDelete {
	mutation := newAppMutation(c.config, OpDelete)
	return &AppDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AppClient) DeleteOne(a *App) *AppDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AppClient) DeleteOneID(id uint64) *AppDeleteOne {
	builder := c.Delete().Where(app.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppDeleteOne{builder}
}

// Query returns a query builder for App.
func (c *AppClient) Query() *AppQuery {
	return &AppQuery{
		config: c.config,
	}
}

// Get returns a App entity by its id.
func (c *AppClient) Get(ctx context.Context, id uint64) (*App, error) {
	return c.Query().Where(app.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppClient) GetX(ctx context.Context, id uint64) *App {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAppOptions queries the appOptions edge of a App.
func (c *AppClient) QueryAppOptions(a *App) *AppOptionQuery {
	query := &AppOptionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(appoption.Table, appoption.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.AppOptionsTable, app.AppOptionsColumn),
		)
		schemaConfig := a.schemaConfig
		step.To.Schema = schemaConfig.AppOption
		step.Edge.Schema = schemaConfig.AppOption
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppClient) Hooks() []Hook {
	return c.hooks.App
}

// AppOptionClient is a client for the AppOption schema.
type AppOptionClient struct {
	config
}

// NewAppOptionClient returns a client for the AppOption from the given config.
func NewAppOptionClient(c config) *AppOptionClient {
	return &AppOptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appoption.Hooks(f(g(h())))`.
func (c *AppOptionClient) Use(hooks ...Hook) {
	c.hooks.AppOption = append(c.hooks.AppOption, hooks...)
}

// Create returns a create builder for AppOption.
func (c *AppOptionClient) Create() *AppOptionCreate {
	mutation := newAppOptionMutation(c.config, OpCreate)
	return &AppOptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppOption entities.
func (c *AppOptionClient) CreateBulk(builders ...*AppOptionCreate) *AppOptionCreateBulk {
	return &AppOptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppOption.
func (c *AppOptionClient) Update() *AppOptionUpdate {
	mutation := newAppOptionMutation(c.config, OpUpdate)
	return &AppOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppOptionClient) UpdateOne(ao *AppOption) *AppOptionUpdateOne {
	mutation := newAppOptionMutation(c.config, OpUpdateOne, withAppOption(ao))
	return &AppOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppOptionClient) UpdateOneID(id uint64) *AppOptionUpdateOne {
	mutation := newAppOptionMutation(c.config, OpUpdateOne, withAppOptionID(id))
	return &AppOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppOption.
func (c *AppOptionClient) Delete() *AppOptionDelete {
	mutation := newAppOptionMutation(c.config, OpDelete)
	return &AppOptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AppOptionClient) DeleteOne(ao *AppOption) *AppOptionDeleteOne {
	return c.DeleteOneID(ao.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AppOptionClient) DeleteOneID(id uint64) *AppOptionDeleteOne {
	builder := c.Delete().Where(appoption.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppOptionDeleteOne{builder}
}

// Query returns a query builder for AppOption.
func (c *AppOptionClient) Query() *AppOptionQuery {
	return &AppOptionQuery{
		config: c.config,
	}
}

// Get returns a AppOption entity by its id.
func (c *AppOptionClient) Get(ctx context.Context, id uint64) (*AppOption, error) {
	return c.Query().Where(appoption.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppOptionClient) GetX(ctx context.Context, id uint64) *AppOption {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a AppOption.
func (c *AppOptionClient) QueryApp(ao *AppOption) *AppQuery {
	query := &AppQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ao.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(appoption.Table, appoption.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, appoption.AppTable, appoption.AppColumn),
		)
		schemaConfig := ao.schemaConfig
		step.To.Schema = schemaConfig.App
		step.Edge.Schema = schemaConfig.AppOption
		fromV = sqlgraph.Neighbors(ao.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppOptionClient) Hooks() []Hook {
	return c.hooks.AppOption
}

// AppUserClient is a client for the AppUser schema.
type AppUserClient struct {
	config
}

// NewAppUserClient returns a client for the AppUser from the given config.
func NewAppUserClient(c config) *AppUserClient {
	return &AppUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appuser.Hooks(f(g(h())))`.
func (c *AppUserClient) Use(hooks ...Hook) {
	c.hooks.AppUser = append(c.hooks.AppUser, hooks...)
}

// Create returns a create builder for AppUser.
func (c *AppUserClient) Create() *AppUserCreate {
	mutation := newAppUserMutation(c.config, OpCreate)
	return &AppUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppUser entities.
func (c *AppUserClient) CreateBulk(builders ...*AppUserCreate) *AppUserCreateBulk {
	return &AppUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppUser.
func (c *AppUserClient) Update() *AppUserUpdate {
	mutation := newAppUserMutation(c.config, OpUpdate)
	return &AppUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppUserClient) UpdateOne(au *AppUser) *AppUserUpdateOne {
	mutation := newAppUserMutation(c.config, OpUpdateOne, withAppUser(au))
	return &AppUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppUserClient) UpdateOneID(id uint64) *AppUserUpdateOne {
	mutation := newAppUserMutation(c.config, OpUpdateOne, withAppUserID(id))
	return &AppUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppUser.
func (c *AppUserClient) Delete() *AppUserDelete {
	mutation := newAppUserMutation(c.config, OpDelete)
	return &AppUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AppUserClient) DeleteOne(au *AppUser) *AppUserDeleteOne {
	return c.DeleteOneID(au.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AppUserClient) DeleteOneID(id uint64) *AppUserDeleteOne {
	builder := c.Delete().Where(appuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppUserDeleteOne{builder}
}

// Query returns a query builder for AppUser.
func (c *AppUserClient) Query() *AppUserQuery {
	return &AppUserQuery{
		config: c.config,
	}
}

// Get returns a AppUser entity by its id.
func (c *AppUserClient) Get(ctx context.Context, id uint64) (*AppUser, error) {
	return c.Query().Where(appuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppUserClient) GetX(ctx context.Context, id uint64) *AppUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a AppUser.
func (c *AppUserClient) QueryApp(au *AppUser) *AppQuery {
	query := &AppQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := au.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(appuser.Table, appuser.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, appuser.AppTable, appuser.AppColumn),
		)
		schemaConfig := au.schemaConfig
		step.To.Schema = schemaConfig.App
		step.Edge.Schema = schemaConfig.AppUser
		fromV = sqlgraph.Neighbors(au.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a AppUser.
func (c *AppUserClient) QueryUser(au *AppUser) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := au.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(appuser.Table, appuser.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, appuser.UserTable, appuser.UserColumn),
		)
		schemaConfig := au.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.AppUser
		fromV = sqlgraph.Neighbors(au.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppUserClient) Hooks() []Hook {
	return c.hooks.AppUser
}

// AppUserLoginLogClient is a client for the AppUserLoginLog schema.
type AppUserLoginLogClient struct {
	config
}

// NewAppUserLoginLogClient returns a client for the AppUserLoginLog from the given config.
func NewAppUserLoginLogClient(c config) *AppUserLoginLogClient {
	return &AppUserLoginLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appuserloginlog.Hooks(f(g(h())))`.
func (c *AppUserLoginLogClient) Use(hooks ...Hook) {
	c.hooks.AppUserLoginLog = append(c.hooks.AppUserLoginLog, hooks...)
}

// Create returns a create builder for AppUserLoginLog.
func (c *AppUserLoginLogClient) Create() *AppUserLoginLogCreate {
	mutation := newAppUserLoginLogMutation(c.config, OpCreate)
	return &AppUserLoginLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppUserLoginLog entities.
func (c *AppUserLoginLogClient) CreateBulk(builders ...*AppUserLoginLogCreate) *AppUserLoginLogCreateBulk {
	return &AppUserLoginLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppUserLoginLog.
func (c *AppUserLoginLogClient) Update() *AppUserLoginLogUpdate {
	mutation := newAppUserLoginLogMutation(c.config, OpUpdate)
	return &AppUserLoginLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppUserLoginLogClient) UpdateOne(aull *AppUserLoginLog) *AppUserLoginLogUpdateOne {
	mutation := newAppUserLoginLogMutation(c.config, OpUpdateOne, withAppUserLoginLog(aull))
	return &AppUserLoginLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppUserLoginLogClient) UpdateOneID(id uint64) *AppUserLoginLogUpdateOne {
	mutation := newAppUserLoginLogMutation(c.config, OpUpdateOne, withAppUserLoginLogID(id))
	return &AppUserLoginLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppUserLoginLog.
func (c *AppUserLoginLogClient) Delete() *AppUserLoginLogDelete {
	mutation := newAppUserLoginLogMutation(c.config, OpDelete)
	return &AppUserLoginLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AppUserLoginLogClient) DeleteOne(aull *AppUserLoginLog) *AppUserLoginLogDeleteOne {
	return c.DeleteOneID(aull.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AppUserLoginLogClient) DeleteOneID(id uint64) *AppUserLoginLogDeleteOne {
	builder := c.Delete().Where(appuserloginlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppUserLoginLogDeleteOne{builder}
}

// Query returns a query builder for AppUserLoginLog.
func (c *AppUserLoginLogClient) Query() *AppUserLoginLogQuery {
	return &AppUserLoginLogQuery{
		config: c.config,
	}
}

// Get returns a AppUserLoginLog entity by its id.
func (c *AppUserLoginLogClient) Get(ctx context.Context, id uint64) (*AppUserLoginLog, error) {
	return c.Query().Where(appuserloginlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppUserLoginLogClient) GetX(ctx context.Context, id uint64) *AppUserLoginLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a AppUserLoginLog.
func (c *AppUserLoginLogClient) QueryApp(aull *AppUserLoginLog) *AppQuery {
	query := &AppQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := aull.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(appuserloginlog.Table, appuserloginlog.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, appuserloginlog.AppTable, appuserloginlog.AppColumn),
		)
		schemaConfig := aull.schemaConfig
		step.To.Schema = schemaConfig.App
		step.Edge.Schema = schemaConfig.AppUserLoginLog
		fromV = sqlgraph.Neighbors(aull.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAppUser queries the appUser edge of a AppUserLoginLog.
func (c *AppUserLoginLogClient) QueryAppUser(aull *AppUserLoginLog) *AppUserQuery {
	query := &AppUserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := aull.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(appuserloginlog.Table, appuserloginlog.FieldID, id),
			sqlgraph.To(appuser.Table, appuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, appuserloginlog.AppUserTable, appuserloginlog.AppUserColumn),
		)
		schemaConfig := aull.schemaConfig
		step.To.Schema = schemaConfig.AppUser
		step.Edge.Schema = schemaConfig.AppUserLoginLog
		fromV = sqlgraph.Neighbors(aull.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a AppUserLoginLog.
func (c *AppUserLoginLogClient) QueryUser(aull *AppUserLoginLog) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := aull.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(appuserloginlog.Table, appuserloginlog.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, appuserloginlog.UserTable, appuserloginlog.UserColumn),
		)
		schemaConfig := aull.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.AppUserLoginLog
		fromV = sqlgraph.Neighbors(aull.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppUserLoginLogClient) Hooks() []Hook {
	return c.hooks.AppUserLoginLog
}

// AppUserTokenClient is a client for the AppUserToken schema.
type AppUserTokenClient struct {
	config
}

// NewAppUserTokenClient returns a client for the AppUserToken from the given config.
func NewAppUserTokenClient(c config) *AppUserTokenClient {
	return &AppUserTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appusertoken.Hooks(f(g(h())))`.
func (c *AppUserTokenClient) Use(hooks ...Hook) {
	c.hooks.AppUserToken = append(c.hooks.AppUserToken, hooks...)
}

// Create returns a create builder for AppUserToken.
func (c *AppUserTokenClient) Create() *AppUserTokenCreate {
	mutation := newAppUserTokenMutation(c.config, OpCreate)
	return &AppUserTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppUserToken entities.
func (c *AppUserTokenClient) CreateBulk(builders ...*AppUserTokenCreate) *AppUserTokenCreateBulk {
	return &AppUserTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppUserToken.
func (c *AppUserTokenClient) Update() *AppUserTokenUpdate {
	mutation := newAppUserTokenMutation(c.config, OpUpdate)
	return &AppUserTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppUserTokenClient) UpdateOne(aut *AppUserToken) *AppUserTokenUpdateOne {
	mutation := newAppUserTokenMutation(c.config, OpUpdateOne, withAppUserToken(aut))
	return &AppUserTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppUserTokenClient) UpdateOneID(id uint64) *AppUserTokenUpdateOne {
	mutation := newAppUserTokenMutation(c.config, OpUpdateOne, withAppUserTokenID(id))
	return &AppUserTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppUserToken.
func (c *AppUserTokenClient) Delete() *AppUserTokenDelete {
	mutation := newAppUserTokenMutation(c.config, OpDelete)
	return &AppUserTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AppUserTokenClient) DeleteOne(aut *AppUserToken) *AppUserTokenDeleteOne {
	return c.DeleteOneID(aut.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AppUserTokenClient) DeleteOneID(id uint64) *AppUserTokenDeleteOne {
	builder := c.Delete().Where(appusertoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppUserTokenDeleteOne{builder}
}

// Query returns a query builder for AppUserToken.
func (c *AppUserTokenClient) Query() *AppUserTokenQuery {
	return &AppUserTokenQuery{
		config: c.config,
	}
}

// Get returns a AppUserToken entity by its id.
func (c *AppUserTokenClient) Get(ctx context.Context, id uint64) (*AppUserToken, error) {
	return c.Query().Where(appusertoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppUserTokenClient) GetX(ctx context.Context, id uint64) *AppUserToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a AppUserToken.
func (c *AppUserTokenClient) QueryApp(aut *AppUserToken) *AppQuery {
	query := &AppQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := aut.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(appusertoken.Table, appusertoken.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, appusertoken.AppTable, appusertoken.AppColumn),
		)
		schemaConfig := aut.schemaConfig
		step.To.Schema = schemaConfig.App
		step.Edge.Schema = schemaConfig.AppUserToken
		fromV = sqlgraph.Neighbors(aut.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAppUser queries the appUser edge of a AppUserToken.
func (c *AppUserTokenClient) QueryAppUser(aut *AppUserToken) *AppUserQuery {
	query := &AppUserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := aut.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(appusertoken.Table, appusertoken.FieldID, id),
			sqlgraph.To(appuser.Table, appuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, appusertoken.AppUserTable, appusertoken.AppUserColumn),
		)
		schemaConfig := aut.schemaConfig
		step.To.Schema = schemaConfig.AppUser
		step.Edge.Schema = schemaConfig.AppUserToken
		fromV = sqlgraph.Neighbors(aut.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a AppUserToken.
func (c *AppUserTokenClient) QueryUser(aut *AppUserToken) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := aut.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(appusertoken.Table, appusertoken.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, appusertoken.UserTable, appusertoken.UserColumn),
		)
		schemaConfig := aut.schemaConfig
		step.To.Schema = schemaConfig.User
		step.Edge.Schema = schemaConfig.AppUserToken
		fromV = sqlgraph.Neighbors(aut.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppUserTokenClient) Hooks() []Hook {
	return c.hooks.AppUserToken
}

// AuthAssgimentClient is a client for the AuthAssgiment schema.
type AuthAssgimentClient struct {
	config
}

// NewAuthAssgimentClient returns a client for the AuthAssgiment from the given config.
func NewAuthAssgimentClient(c config) *AuthAssgimentClient {
	return &AuthAssgimentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authassgiment.Hooks(f(g(h())))`.
func (c *AuthAssgimentClient) Use(hooks ...Hook) {
	c.hooks.AuthAssgiment = append(c.hooks.AuthAssgiment, hooks...)
}

// Create returns a create builder for AuthAssgiment.
func (c *AuthAssgimentClient) Create() *AuthAssgimentCreate {
	mutation := newAuthAssgimentMutation(c.config, OpCreate)
	return &AuthAssgimentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthAssgiment entities.
func (c *AuthAssgimentClient) CreateBulk(builders ...*AuthAssgimentCreate) *AuthAssgimentCreateBulk {
	return &AuthAssgimentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthAssgiment.
func (c *AuthAssgimentClient) Update() *AuthAssgimentUpdate {
	mutation := newAuthAssgimentMutation(c.config, OpUpdate)
	return &AuthAssgimentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthAssgimentClient) UpdateOne(aa *AuthAssgiment) *AuthAssgimentUpdateOne {
	mutation := newAuthAssgimentMutation(c.config, OpUpdateOne, withAuthAssgiment(aa))
	return &AuthAssgimentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthAssgimentClient) UpdateOneID(id int) *AuthAssgimentUpdateOne {
	mutation := newAuthAssgimentMutation(c.config, OpUpdateOne, withAuthAssgimentID(id))
	return &AuthAssgimentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthAssgiment.
func (c *AuthAssgimentClient) Delete() *AuthAssgimentDelete {
	mutation := newAuthAssgimentMutation(c.config, OpDelete)
	return &AuthAssgimentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AuthAssgimentClient) DeleteOne(aa *AuthAssgiment) *AuthAssgimentDeleteOne {
	return c.DeleteOneID(aa.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AuthAssgimentClient) DeleteOneID(id int) *AuthAssgimentDeleteOne {
	builder := c.Delete().Where(authassgiment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthAssgimentDeleteOne{builder}
}

// Query returns a query builder for AuthAssgiment.
func (c *AuthAssgimentClient) Query() *AuthAssgimentQuery {
	return &AuthAssgimentQuery{
		config: c.config,
	}
}

// Get returns a AuthAssgiment entity by its id.
func (c *AuthAssgimentClient) Get(ctx context.Context, id int) (*AuthAssgiment, error) {
	return c.Query().Where(authassgiment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthAssgimentClient) GetX(ctx context.Context, id int) *AuthAssgiment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthAssgimentClient) Hooks() []Hook {
	return c.hooks.AuthAssgiment
}

// AuthItemClient is a client for the AuthItem schema.
type AuthItemClient struct {
	config
}

// NewAuthItemClient returns a client for the AuthItem from the given config.
func NewAuthItemClient(c config) *AuthItemClient {
	return &AuthItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authitem.Hooks(f(g(h())))`.
func (c *AuthItemClient) Use(hooks ...Hook) {
	c.hooks.AuthItem = append(c.hooks.AuthItem, hooks...)
}

// Create returns a create builder for AuthItem.
func (c *AuthItemClient) Create() *AuthItemCreate {
	mutation := newAuthItemMutation(c.config, OpCreate)
	return &AuthItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthItem entities.
func (c *AuthItemClient) CreateBulk(builders ...*AuthItemCreate) *AuthItemCreateBulk {
	return &AuthItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthItem.
func (c *AuthItemClient) Update() *AuthItemUpdate {
	mutation := newAuthItemMutation(c.config, OpUpdate)
	return &AuthItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthItemClient) UpdateOne(ai *AuthItem) *AuthItemUpdateOne {
	mutation := newAuthItemMutation(c.config, OpUpdateOne, withAuthItem(ai))
	return &AuthItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthItemClient) UpdateOneID(id int) *AuthItemUpdateOne {
	mutation := newAuthItemMutation(c.config, OpUpdateOne, withAuthItemID(id))
	return &AuthItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthItem.
func (c *AuthItemClient) Delete() *AuthItemDelete {
	mutation := newAuthItemMutation(c.config, OpDelete)
	return &AuthItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AuthItemClient) DeleteOne(ai *AuthItem) *AuthItemDeleteOne {
	return c.DeleteOneID(ai.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AuthItemClient) DeleteOneID(id int) *AuthItemDeleteOne {
	builder := c.Delete().Where(authitem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthItemDeleteOne{builder}
}

// Query returns a query builder for AuthItem.
func (c *AuthItemClient) Query() *AuthItemQuery {
	return &AuthItemQuery{
		config: c.config,
	}
}

// Get returns a AuthItem entity by its id.
func (c *AuthItemClient) Get(ctx context.Context, id int) (*AuthItem, error) {
	return c.Query().Where(authitem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthItemClient) GetX(ctx context.Context, id int) *AuthItem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthItemClient) Hooks() []Hook {
	return c.hooks.AuthItem
}

// AuthItemChildClient is a client for the AuthItemChild schema.
type AuthItemChildClient struct {
	config
}

// NewAuthItemChildClient returns a client for the AuthItemChild from the given config.
func NewAuthItemChildClient(c config) *AuthItemChildClient {
	return &AuthItemChildClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authitemchild.Hooks(f(g(h())))`.
func (c *AuthItemChildClient) Use(hooks ...Hook) {
	c.hooks.AuthItemChild = append(c.hooks.AuthItemChild, hooks...)
}

// Create returns a create builder for AuthItemChild.
func (c *AuthItemChildClient) Create() *AuthItemChildCreate {
	mutation := newAuthItemChildMutation(c.config, OpCreate)
	return &AuthItemChildCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthItemChild entities.
func (c *AuthItemChildClient) CreateBulk(builders ...*AuthItemChildCreate) *AuthItemChildCreateBulk {
	return &AuthItemChildCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthItemChild.
func (c *AuthItemChildClient) Update() *AuthItemChildUpdate {
	mutation := newAuthItemChildMutation(c.config, OpUpdate)
	return &AuthItemChildUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthItemChildClient) UpdateOne(aic *AuthItemChild) *AuthItemChildUpdateOne {
	mutation := newAuthItemChildMutation(c.config, OpUpdateOne, withAuthItemChild(aic))
	return &AuthItemChildUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthItemChildClient) UpdateOneID(id int) *AuthItemChildUpdateOne {
	mutation := newAuthItemChildMutation(c.config, OpUpdateOne, withAuthItemChildID(id))
	return &AuthItemChildUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthItemChild.
func (c *AuthItemChildClient) Delete() *AuthItemChildDelete {
	mutation := newAuthItemChildMutation(c.config, OpDelete)
	return &AuthItemChildDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AuthItemChildClient) DeleteOne(aic *AuthItemChild) *AuthItemChildDeleteOne {
	return c.DeleteOneID(aic.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AuthItemChildClient) DeleteOneID(id int) *AuthItemChildDeleteOne {
	builder := c.Delete().Where(authitemchild.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthItemChildDeleteOne{builder}
}

// Query returns a query builder for AuthItemChild.
func (c *AuthItemChildClient) Query() *AuthItemChildQuery {
	return &AuthItemChildQuery{
		config: c.config,
	}
}

// Get returns a AuthItemChild entity by its id.
func (c *AuthItemChildClient) Get(ctx context.Context, id int) (*AuthItemChild, error) {
	return c.Query().Where(authitemchild.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthItemChildClient) GetX(ctx context.Context, id int) *AuthItemChild {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthItemChildClient) Hooks() []Hook {
	return c.hooks.AuthItemChild
}

// AuthRoleClient is a client for the AuthRole schema.
type AuthRoleClient struct {
	config
}

// NewAuthRoleClient returns a client for the AuthRole from the given config.
func NewAuthRoleClient(c config) *AuthRoleClient {
	return &AuthRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authrole.Hooks(f(g(h())))`.
func (c *AuthRoleClient) Use(hooks ...Hook) {
	c.hooks.AuthRole = append(c.hooks.AuthRole, hooks...)
}

// Create returns a create builder for AuthRole.
func (c *AuthRoleClient) Create() *AuthRoleCreate {
	mutation := newAuthRoleMutation(c.config, OpCreate)
	return &AuthRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthRole entities.
func (c *AuthRoleClient) CreateBulk(builders ...*AuthRoleCreate) *AuthRoleCreateBulk {
	return &AuthRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthRole.
func (c *AuthRoleClient) Update() *AuthRoleUpdate {
	mutation := newAuthRoleMutation(c.config, OpUpdate)
	return &AuthRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthRoleClient) UpdateOne(ar *AuthRole) *AuthRoleUpdateOne {
	mutation := newAuthRoleMutation(c.config, OpUpdateOne, withAuthRole(ar))
	return &AuthRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthRoleClient) UpdateOneID(id int) *AuthRoleUpdateOne {
	mutation := newAuthRoleMutation(c.config, OpUpdateOne, withAuthRoleID(id))
	return &AuthRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthRole.
func (c *AuthRoleClient) Delete() *AuthRoleDelete {
	mutation := newAuthRoleMutation(c.config, OpDelete)
	return &AuthRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AuthRoleClient) DeleteOne(ar *AuthRole) *AuthRoleDeleteOne {
	return c.DeleteOneID(ar.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AuthRoleClient) DeleteOneID(id int) *AuthRoleDeleteOne {
	builder := c.Delete().Where(authrole.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthRoleDeleteOne{builder}
}

// Query returns a query builder for AuthRole.
func (c *AuthRoleClient) Query() *AuthRoleQuery {
	return &AuthRoleQuery{
		config: c.config,
	}
}

// Get returns a AuthRole entity by its id.
func (c *AuthRoleClient) Get(ctx context.Context, id int) (*AuthRole, error) {
	return c.Query().Where(authrole.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthRoleClient) GetX(ctx context.Context, id int) *AuthRole {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthRoleClient) Hooks() []Hook {
	return c.hooks.AuthRole
}

// AuthRuleClient is a client for the AuthRule schema.
type AuthRuleClient struct {
	config
}

// NewAuthRuleClient returns a client for the AuthRule from the given config.
func NewAuthRuleClient(c config) *AuthRuleClient {
	return &AuthRuleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authrule.Hooks(f(g(h())))`.
func (c *AuthRuleClient) Use(hooks ...Hook) {
	c.hooks.AuthRule = append(c.hooks.AuthRule, hooks...)
}

// Create returns a create builder for AuthRule.
func (c *AuthRuleClient) Create() *AuthRuleCreate {
	mutation := newAuthRuleMutation(c.config, OpCreate)
	return &AuthRuleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthRule entities.
func (c *AuthRuleClient) CreateBulk(builders ...*AuthRuleCreate) *AuthRuleCreateBulk {
	return &AuthRuleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthRule.
func (c *AuthRuleClient) Update() *AuthRuleUpdate {
	mutation := newAuthRuleMutation(c.config, OpUpdate)
	return &AuthRuleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthRuleClient) UpdateOne(ar *AuthRule) *AuthRuleUpdateOne {
	mutation := newAuthRuleMutation(c.config, OpUpdateOne, withAuthRule(ar))
	return &AuthRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthRuleClient) UpdateOneID(id int) *AuthRuleUpdateOne {
	mutation := newAuthRuleMutation(c.config, OpUpdateOne, withAuthRuleID(id))
	return &AuthRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthRule.
func (c *AuthRuleClient) Delete() *AuthRuleDelete {
	mutation := newAuthRuleMutation(c.config, OpDelete)
	return &AuthRuleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AuthRuleClient) DeleteOne(ar *AuthRule) *AuthRuleDeleteOne {
	return c.DeleteOneID(ar.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AuthRuleClient) DeleteOneID(id int) *AuthRuleDeleteOne {
	builder := c.Delete().Where(authrule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthRuleDeleteOne{builder}
}

// Query returns a query builder for AuthRule.
func (c *AuthRuleClient) Query() *AuthRuleQuery {
	return &AuthRuleQuery{
		config: c.config,
	}
}

// Get returns a AuthRule entity by its id.
func (c *AuthRuleClient) Get(ctx context.Context, id int) (*AuthRule, error) {
	return c.Query().Where(authrule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthRuleClient) GetX(ctx context.Context, id int) *AuthRule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthRuleClient) Hooks() []Hook {
	return c.hooks.AuthRule
}

// EmailLogClient is a client for the EmailLog schema.
type EmailLogClient struct {
	config
}

// NewEmailLogClient returns a client for the EmailLog from the given config.
func NewEmailLogClient(c config) *EmailLogClient {
	return &EmailLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `emaillog.Hooks(f(g(h())))`.
func (c *EmailLogClient) Use(hooks ...Hook) {
	c.hooks.EmailLog = append(c.hooks.EmailLog, hooks...)
}

// Create returns a create builder for EmailLog.
func (c *EmailLogClient) Create() *EmailLogCreate {
	mutation := newEmailLogMutation(c.config, OpCreate)
	return &EmailLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EmailLog entities.
func (c *EmailLogClient) CreateBulk(builders ...*EmailLogCreate) *EmailLogCreateBulk {
	return &EmailLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EmailLog.
func (c *EmailLogClient) Update() *EmailLogUpdate {
	mutation := newEmailLogMutation(c.config, OpUpdate)
	return &EmailLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EmailLogClient) UpdateOne(el *EmailLog) *EmailLogUpdateOne {
	mutation := newEmailLogMutation(c.config, OpUpdateOne, withEmailLog(el))
	return &EmailLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EmailLogClient) UpdateOneID(id uint64) *EmailLogUpdateOne {
	mutation := newEmailLogMutation(c.config, OpUpdateOne, withEmailLogID(id))
	return &EmailLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EmailLog.
func (c *EmailLogClient) Delete() *EmailLogDelete {
	mutation := newEmailLogMutation(c.config, OpDelete)
	return &EmailLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *EmailLogClient) DeleteOne(el *EmailLog) *EmailLogDeleteOne {
	return c.DeleteOneID(el.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *EmailLogClient) DeleteOneID(id uint64) *EmailLogDeleteOne {
	builder := c.Delete().Where(emaillog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EmailLogDeleteOne{builder}
}

// Query returns a query builder for EmailLog.
func (c *EmailLogClient) Query() *EmailLogQuery {
	return &EmailLogQuery{
		config: c.config,
	}
}

// Get returns a EmailLog entity by its id.
func (c *EmailLogClient) Get(ctx context.Context, id uint64) (*EmailLog, error) {
	return c.Query().Where(emaillog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EmailLogClient) GetX(ctx context.Context, id uint64) *EmailLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a EmailLog.
func (c *EmailLogClient) QueryApp(el *EmailLog) *AppQuery {
	query := &AppQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := el.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(emaillog.Table, emaillog.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, emaillog.AppTable, emaillog.AppColumn),
		)
		schemaConfig := el.schemaConfig
		step.To.Schema = schemaConfig.App
		step.Edge.Schema = schemaConfig.EmailLog
		fromV = sqlgraph.Neighbors(el.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EmailLogClient) Hooks() []Hook {
	return c.hooks.EmailLog
}

// SmsLogClient is a client for the SmsLog schema.
type SmsLogClient struct {
	config
}

// NewSmsLogClient returns a client for the SmsLog from the given config.
func NewSmsLogClient(c config) *SmsLogClient {
	return &SmsLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `smslog.Hooks(f(g(h())))`.
func (c *SmsLogClient) Use(hooks ...Hook) {
	c.hooks.SmsLog = append(c.hooks.SmsLog, hooks...)
}

// Create returns a create builder for SmsLog.
func (c *SmsLogClient) Create() *SmsLogCreate {
	mutation := newSmsLogMutation(c.config, OpCreate)
	return &SmsLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SmsLog entities.
func (c *SmsLogClient) CreateBulk(builders ...*SmsLogCreate) *SmsLogCreateBulk {
	return &SmsLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SmsLog.
func (c *SmsLogClient) Update() *SmsLogUpdate {
	mutation := newSmsLogMutation(c.config, OpUpdate)
	return &SmsLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SmsLogClient) UpdateOne(sl *SmsLog) *SmsLogUpdateOne {
	mutation := newSmsLogMutation(c.config, OpUpdateOne, withSmsLog(sl))
	return &SmsLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SmsLogClient) UpdateOneID(id uint64) *SmsLogUpdateOne {
	mutation := newSmsLogMutation(c.config, OpUpdateOne, withSmsLogID(id))
	return &SmsLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SmsLog.
func (c *SmsLogClient) Delete() *SmsLogDelete {
	mutation := newSmsLogMutation(c.config, OpDelete)
	return &SmsLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SmsLogClient) DeleteOne(sl *SmsLog) *SmsLogDeleteOne {
	return c.DeleteOneID(sl.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SmsLogClient) DeleteOneID(id uint64) *SmsLogDeleteOne {
	builder := c.Delete().Where(smslog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SmsLogDeleteOne{builder}
}

// Query returns a query builder for SmsLog.
func (c *SmsLogClient) Query() *SmsLogQuery {
	return &SmsLogQuery{
		config: c.config,
	}
}

// Get returns a SmsLog entity by its id.
func (c *SmsLogClient) Get(ctx context.Context, id uint64) (*SmsLog, error) {
	return c.Query().Where(smslog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SmsLogClient) GetX(ctx context.Context, id uint64) *SmsLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApp queries the app edge of a SmsLog.
func (c *SmsLogClient) QueryApp(sl *SmsLog) *AppQuery {
	query := &AppQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := sl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(smslog.Table, smslog.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, smslog.AppTable, smslog.AppColumn),
		)
		schemaConfig := sl.schemaConfig
		step.To.Schema = schemaConfig.App
		step.Edge.Schema = schemaConfig.SmsLog
		fromV = sqlgraph.Neighbors(sl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SmsLogClient) Hooks() []Hook {
	return c.hooks.SmsLog
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a create builder for User.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uint64) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserClient) DeleteOneID(id uint64) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uint64) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uint64) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}
